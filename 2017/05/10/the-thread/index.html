<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>线程到底是什么？ | N.Y.</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Mac OS X,XNU,pthread,Runloop,GCD," />
  

  <meta name="description" content="前言本文是以笔者学习中遇到的一个小场景作为线索，从而引发笔者诸如“什么是进程？”“什么是线程？” “GCD 和线程关系是什么？” “NSRunLoop 是什么？”“NSRunLoop 和线程关系是什么？”等诸多疑问，随后又根据这些疑问，一步步抽丝剥茧，找寻这些问题答案的文章。 本文篇幅较长，文章梗概如下。  一个在 OS X Command Line 中出现的与线程有关的场景。 探究进程和线程 探">
<meta property="og:type" content="article">
<meta property="og:title" content="线程到底是什么？">
<meta property="og:url" content="http://niyaoyao.me/2017/05/10/the-thread/index.html">
<meta property="og:site_name" content="N.Y.">
<meta property="og:description" content="前言本文是以笔者学习中遇到的一个小场景作为线索，从而引发笔者诸如“什么是进程？”“什么是线程？” “GCD 和线程关系是什么？” “NSRunLoop 是什么？”“NSRunLoop 和线程关系是什么？”等诸多疑问，随后又根据这些疑问，一步步抽丝剥茧，找寻这些问题答案的文章。 本文篇幅较长，文章梗概如下。  一个在 OS X Command Line 中出现的与线程有关的场景。 探究进程和线程 探">
<meta property="og:locale">
<meta property="og:image" content="https://niyaoyao.github.io/images/apple-architecture-x86-architecture.png">
<meta property="og:image" content="https://niyaoyao.github.io/images/darwin_structure.png">
<meta property="og:image" content="https://niyaoyao.github.io/images/apple-architecture-lldb-callstacksymbols.png">
<meta property="og:image" content="https://niyaoyao.github.io/images/gcd-queue.png">
<meta property="og:image" content="https://www.objc.io/images/issue-2/gcd-queues@2x-82965db9.png">
<meta property="og:image" content="https://niyaoyao.github.io/images/system_call.png">
<meta property="og:image" content="https://niyaoyao.github.io/images/flow-of-thread-creation.png">
<meta property="og:image" content="https://niyaoyao.github.io/images/nsthread-callstacksymbols.png">
<meta property="og:image" content="https://niyaoyao.github.io/images/runloop.png">
<meta property="article:published_time" content="2017-05-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-04T07:01:51.204Z">
<meta property="article:author" content="Niyao">
<meta property="article:tag" content="Mac OS X">
<meta property="article:tag" content="XNU">
<meta property="article:tag" content="pthread">
<meta property="article:tag" content="Runloop">
<meta property="article:tag" content="GCD">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://niyaoyao.github.io/images/apple-architecture-x86-architecture.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%86%8D%E7%8E%B0"><span class="toc-text">场景再现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89"><span class="toc-text">资源竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%E7%9A%84%E7%AB%9E%E4%BA%89%EF%BC%9A%E5%88%86%E9%A1%B5"><span class="toc-text">解决内存资源的竞争：分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-CPU-%E8%B5%84%E6%BA%90%E7%9A%84%E7%AB%9E%E4%BA%89%EF%BC%9A%E8%B0%83%E5%BA%A6"><span class="toc-text">解决 CPU 资源的竞争：调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GCD-%E6%BA%90%E7%A0%81%E7%A0%94%E8%AF%BB"><span class="toc-text">GCD 源码研读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-GCD-%E9%98%9F%E5%88%97"><span class="toc-text">创建 GCD 队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-Timer-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83"><span class="toc-text">设置 Timer 事件回调</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thead"><span class="toc-text">Thead</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BSD-%E5%B1%82%E7%9A%84-pthread"><span class="toc-text">BSD 层的 pthread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mach-thread-%E4%B8%8E-pthread-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">Mach thread 与 pthread 的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Run-Loop"><span class="toc-text">Run Loop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NSRunLoop-%E4%B8%8E-CFRunLoop"><span class="toc-text">NSRunLoop 与 CFRunLoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFRunLoop-%E7%9B%B8%E5%85%B3-API"><span class="toc-text">CFRunLoop 相关 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observer"><span class="toc-text">Observer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer"><span class="toc-text">Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Source"><span class="toc-text">Source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFRunLoopRun"><span class="toc-text">CFRunLoopRun</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E5%BD%A9%E8%9B%8B"><span class="toc-text">小彩蛋</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E6%A1%88%E4%BE%8B%E6%BA%90%E7%A0%81"><span class="toc-text">本文案例源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Apple-Opensource-%E6%9F%A5%E9%98%85%E6%8C%87%E5%8D%97"><span class="toc-text">Apple Opensource 查阅指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-text">源码说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-the-thread" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">线程到底是什么？</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.05.10</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Niyao</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Mac-OS-X/">Mac OS X</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是以笔者学习中遇到的一个小场景作为线索，从而引发笔者诸如“什么是进程？”“什么是线程？” “GCD 和线程关系是什么？” “NSRunLoop 是什么？”“NSRunLoop 和线程关系是什么？”等诸多疑问，随后又根据这些疑问，一步步抽丝剥茧，找寻这些问题答案的文章。</p>
<p>本文篇幅较长，文章梗概如下。</p>
<ul>
<li>一个在 OS X Command Line 中出现的与线程有关的场景。</li>
<li>探究进程和线程</li>
<li>探究 GCD 库</li>
<li>探究 BSD／POSIX 的 pthread 和 Mach 抽象层的 thread</li>
<li>探究 NSRunloop(CFRunloop) </li>
</ul>
<p>_如果你对线程底层实现以及 XNU 内核感兴趣，或许这篇文章会对你有帮助。本文大部分是探究的过程，如果想跳过过程，可直接点击<a target="_blank" rel="noopener" href="https://niyaoyao.github.io/2017/05/10/what-the-thread-it-is/#结论">结论</a>_</p>
<h1 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h1><p>某天，笔者想在 OS X Command Line 的 main 函数直接创建 timer，输出 CPU 使用和内存使用数据。代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> <span class="title function_">monitor_queue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_queue_t</span> monitor_queue;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        monitor_queue = dispatch_queue_create(<span class="string">&quot;ny.monitor.queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> monitor_queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="type">dispatch_source_t</span> timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, monitor_queue());</span><br><span class="line">        dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">1</span> * NSEC_PER_SEC, <span class="number">0</span> * NSEC_PER_SEC);</span><br><span class="line">        dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;CPU Usage[%d]: %f％\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Used Memory/Free Memory : %lu/%lu\n&quot;</span></span><br><span class="line">                   , count++, app_cpu_usage(), get_used_memory(), get_free_memory()); <span class="comment">// print before plus</span></span><br><span class="line">            <span class="keyword">if</span> (!fireTimer) &#123;</span><br><span class="line">                dispatch_source_cancel(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_resume(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，运行程序之后，结果并未如笔者所期望的那样，触发 timer 设置的回调 block，而是直接终止进程，这是什么情况？—— 为什么在 iOS 工程下，可以得到想要的数据输出。然而，完全相同的代码直接复制到命令行工程中，main 函数却直接 return 而结束进程。</p>
<p>笔者百思不解，最终只能求助同事，同事建议尝试开启当前线程的 Run Loop 试试。果然，控制台可以正常输出每秒的 CPU 和内存的使用数据了。然而，笔者就奇怪了，为什么要手动开启线程的 Run Loop 呢？不是说好的主线程的 Run Loop 不需要手动开启嘛，为什么到命令行这就要手动开启呢？这是因为网上大多数文章没有指明 NSRunLoop 默认是在 macOS/iOS 应用的工程中开启，从而也误导了笔者认为 Command Line 同样会开启主线程的运行循环。</p>
<p>在上述这个例子中，开启 Run Loop 以避免线程结束的这种方式，就是所谓的“<strong>创建常驻线程（线程保活）</strong>”，而此场景中的线程只不过是主线程而已。 <strong>在 macOS/iOS 应用中的 AppDelegate（继承自 NSApplicationDelegate/UIApplicationDelegate），已经封装好 Run Loop 对象的相关操作。所以，就不需要开发者手动开启，而作为 Command Line 只包含简单的 main 函数，因而自然不会进行 Run Loop 的开启操作。</strong> 所以，当程序顺序执行完成，主线程的 main 函数就直接 return 从而结束当前进程，而并不等待回调函数中的异步操作了。</p>
<p>虽然 GCD timer 回调事件没有正常触发的问题已经解决了，但笔者仍不免产生这样的疑问，到底什么是进程？什么是线程？GCD 和线程关系是什么？RunLoop 和线程关系是什么？所以，就从这些疑问开始，慢慢找寻其答案。</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>《OS X and iOS Kernel Programming》一书中对进程是这样描述的：</p>
<blockquote>
<p>When the user launches an application, the operating system loads the program’s code and data into memory from disk and begins executing its code. A program being executed is known as a “process.” Unlike a program, a process is an active entity, and consists of a snapshot of the state of the program at a single instance during execution.</p>
</blockquote>
<p>大意为，当用户启动一个应用，系统将程序的源码和数据从磁盘加载到内存中，并且开始执行他的源码。一个进程即一个正被执行中的程序。与程序不同，<strong>一个进程是一个活跃的实体</strong>，并且包含了程序作为单个实例在执行期间状态的快照。</p>
<p>所以，从上述描述我们就可以得知，我们所谓的进程，就是在内存中执行着的程序文件。比如，一个 <strong>ls</strong> 命令，其实就是一个可执行的文件，当其在执行时就是一个进程。而我们如果需要查看当前所执行中的进程，可以使用 <strong>ps awx</strong> 命令。</p>
<p>与此同时，也可以更加了解“<strong>UNIX 操作系统一切皆文件</strong>”基本哲学的奥义。</p>
<blockquote>
<p><strong>思维扩展</strong><br><strong>内核也是一个进程，或者说内核也是内存中执行着的程序文件。</strong>如果想直接拿到内核文件，可以在内存中计算好内存偏移量，然后直接 dump 出来。笔者暂未找到直接 dump 内核的方法，只是某次面试时，面试官老师提过这么一个案例，故而记着了。<br>虽未找到 dump 内核的具体方式，但查到有个导出内核符号表的案例，参见 <a target="_blank" rel="noopener" href="http://bbs.iosre.com/t/kernel-symbols-where-are-you/595">http://bbs.iosre.com/t/kernel-symbols-where-are-you/595</a></p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>了解过进程的基本概念，再来看线程。在《Mac OS X and iOS Internals To the Apple’s Core》中是这样定义线程的：</p>
<blockquote>
<p>Modern operating systems no longer treat processes as the basic units of operation, instead work with threads. A thread is merely a distinct register state, and more than one can exist in a given process. All threads share the virtual memory space, descriptors and handles. </p>
</blockquote>
<p>现在操作系统一部将进程视为操作的基本单元，取而代之的是线程。<strong>一个线程只不过是一组寄存器的状态</strong>，并且一个进程存在多个线程。所有的线程共享虚拟内存空间，文件描述和句柄。</p>
<blockquote>
<p><strong>思维扩展</strong><br>关于“一个线程只不过是一组寄存器的状态”笔者也进行了其他相关资料的考证。可参见如下资料。</p>
<ul>
<li>知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27406575">https://www.zhihu.com/question/27406575</a></li>
<li>Python3 多线程 <a target="_blank" rel="noopener" href="http://learn.jser.com/python3/python3-multithreading.html">http://learn.jser.com/python3/python3-multithreading.html</a></li>
<li>获得 CPU 寄存器状态 <a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/grey-hat-python/content/11.html">https://wizardforcel.gitbooks.io/grey-hat-python/content/11.html</a></li>
</ul>
</blockquote>
<h2 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h2><p><img src="https://niyaoyao.github.io/images/apple-architecture-x86-architecture.png" alt=""></p>
<p>从进程和线程的基本概念可知，进程是内存（RAM）中执行中的程序文件，而线程则是 CPU 一组寄存器的状态。也就是说，所谓进程和线程对象，其实是操作系统在底层硬件的物理元件之上抽象出的实体对象，方便用户（开发人员）编写程序来对系统资源进行合理使用。</p>
<p><img src="https://niyaoyao.github.io/images/darwin_structure.png" alt=""></p>
<p>上图所示为 macOS（OS X）/iOS 的架构图。其中，上层是 macOS/iOS 的用户态架构，下层是 macOS/iOS 的 Darwin（内核态）架构。而 Darwin 最底层是硬件，依次往上分别是 Mach 抽象层、BSD 层，以及内核态/用户态转换层。</p>
<p>我们知道，在计算机中内存和 CPU 的资源都是有限的，所以，内存和 CPU 的资源竞争都非常激烈，接下来就看一下操作系统是如何解决内存和 CPU 资源竞争问题的。</p>
<h3 id="解决内存资源的竞争：分页"><a href="#解决内存资源的竞争：分页" class="headerlink" title="解决内存资源的竞争：分页"></a>解决内存资源的竞争：分页</h3><blockquote>
<p>为了解决内存的竞争，操作系统提供了虚拟内存（Virtual Memory）这样的解决方案，操作系统通常使用一种称为分页（Paging）的方案，实现虚拟地址（硬盘 disk）到物理地址（内存 RAM）的转换。_</p>
<p>—— 摘自《OS X and iOS Kernel Programming》一书</p>
</blockquote>
<p>OS X 和 iOS 都采用了分页机制，但是对于 iOS 而言，分页并没有进行 RAM 和磁盘的交换（Swap），所以，iOS 的内存管理也就仅限于 RAM 的管理。由于本文主要探究线程是什么，所以，对于分页的探究就浅尝辄止了。</p>
<h3 id="解决-CPU-资源的竞争：调度"><a href="#解决-CPU-资源的竞争：调度" class="headerlink" title="解决 CPU 资源的竞争：调度"></a>解决 CPU 资源的竞争：调度</h3><p>内存的资源竞争，操作系统是通过虚拟内存分页解决的。CPU 的资源竞争则是通过调度（Schedule）解决的。</p>
<blockquote>
<p>对于操作系统来说，线程是调度的基本单位；当操作系统调度程序考虑接下来在CPU上调度什么时，只需查看系统上的活动线程。进程如若执行，至少要包含一个线程；一个新进程开始运行时，操作系统会自动为其创建初始线程。<br>调度器有两个作用：防止CPU闲置，否则会浪费宝贵的硬件资源；让所有线程公平地访问CPU，防止因单个线程独占CPU而导致其他线程无法运行。为此，一个线程会在可用的CPU内核上调度执行，直至以下任一事件发生。</p>
<p>—— 《OS X and iOS Kernel Programming》</p>
</blockquote>
<h1 id="GCD-源码研读"><a href="#GCD-源码研读" class="headerlink" title="GCD 源码研读"></a>GCD 源码研读</h1><p>上文已经了解了线程的基本概念，对于 OS X/iOS 的多线程并发编程，GCD 为开发者提供了简单的方式来利用多核处理器的特性，从而提高应用程序并发计算的的效率。</p>
<p>GCD 的作用是，并发执行在多核硬件上提交工作的源码，从而派遣被系统管理的队列。接下来，不妨以开篇场景还原中的代码为线索，按图索骥，看一下 GCD 源码是如何设计的。</p>
<h2 id="创建-GCD-队列"><a href="#创建-GCD-队列" class="headerlink" title="创建 GCD 队列"></a>创建 GCD 队列</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> <span class="title function_">dispatch_queue_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> attr)</span> &#123;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq;</span><br><span class="line">    <span class="type">size_t</span> label_len;</span><br><span class="line">    <span class="comment">// label 校验 ...</span></span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    dq = <span class="built_in">calloc</span>(<span class="number">1ul</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_queue_s) - DISPATCH_QUEUE_MIN_LABEL_SIZE + \</span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    _dispatch_queue_init(dq);</span><br><span class="line">    <span class="built_in">strcpy</span>(dq-&gt;dq_label, label);</span><br><span class="line">    <span class="comment">// some code...</span></span><br><span class="line">    <span class="keyword">return</span> dq;</span><br><span class="line">out_bad:</span><br><span class="line">    <span class="built_in">free</span>(dq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上段代码主要是对 GCD 队列进行创建和初始化操作，其中 <strong>_dispatch_queue_init</strong> 初始化 GCD 队列实例并。再详细看 <strong>_dispatch_queue_init</strong> 这个函数的函数体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dispatch_queue_init(<span class="type">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// some code...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// libdispatch-84.5 的源码</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="type">long</span> priority, <span class="type">bool</span> overcommit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (overcommit) <span class="keyword">switch</span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_root_queues</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.low-priority&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.low-overcommit-priority&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-priority&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.high-priority&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .dq_label = <span class="string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>_dispatch_queue_init</strong> 函数体调用了 <strong>_dispatch_get_root_queue</strong>，并且参数 priority 值为 0（DISPATCH_QUEUE_PRIORITY_DEFAULT），overcommit 为 true，则返回 &amp;_dispatch_root_queues[3]</p>
<p>而 <strong>_dispatch_root_queues</strong> 是一个队列数组，可以得知，<strong>&amp;_dispatch_root_queues[3]</strong> 即为 “com.apple.root.default-priority“ 这个队列，而我们刚才确实也是利用 GCD 创建的后台线程的队列。稍后，我们将探究 GCD 队列与 pthread 的关系。</p>
<p>_以上这段代码利用的是 libdispatch-84.5 的源码，新版本的 _dispatch_root_queues 会有不同，后面探究过程中会使用新版本的定义。_</p>
<h2 id="设置-Timer-事件回调"><a href="#设置-Timer-事件回调" class="headerlink" title="设置 Timer 事件回调"></a>设置 Timer 事件回调</h2><p>在本例中 <strong>dispatch_source_create</strong> 创建 Timer 的 source，而 <strong>dispatch_source_set_timer</strong> 进行 timer 的初始化，具体代码不做深究，仔细来看 <strong>dispatch_source_set_event_handler</strong> 这个方法的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dispatch_source_set_event_handler</span><span class="params">(<span class="type">dispatch_source_t</span> ds, <span class="type">dispatch_block_t</span> handler)</span> &#123;</span><br><span class="line">    dispatch_assert(!ds-&gt;ds_is_legacy);</span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    dispatch_barrier_async_f((<span class="type">dispatch_queue_t</span>)ds,</span><br><span class="line">        handler, _dispatch_source_set_event_handler2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _dispatch_source_set_event_handler2(<span class="type">void</span> *context) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">bl</span> =</span> context;</span><br><span class="line">    <span class="type">dispatch_source_t</span> ds = (<span class="type">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    dispatch_assert(ds-&gt;do_vtable == &amp;_dispatch_source_kevent_vtable);</span><br><span class="line">    <span class="comment">// some other code...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用 <strong>dispatch_barrier_async_f</strong>，设置栅栏函数，使得并发队列仅执行 <strong>_dispatch_source_set_event_handler2</strong> 这个函数，并且将 handler 作为 context 上下文参数传给 <strong>_dispatch_source_set_event_handler2</strong>。</p>
<p>在 <strong>_dispatch_source_set_event_handler2</strong> 这个函数中 <strong>_dispatch_queue_get_current</strong> 比较有意思，是获得当前队列，来看看这个函数的具体实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">dispatch_queue_t</span> _dispatch_queue_get_current(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> * _dispatch_thread_getspecific(<span class="type">unsigned</span> <span class="type">long</span> k) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SIMULATE_5491082) &amp;&amp; (defined(__i386__) || defined(__x86_64__))</span></span><br><span class="line">    <span class="comment">// 汇编处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (_pthread_has_direct_tsd()) &#123;</span><br><span class="line">        <span class="keyword">return</span> _pthread_getspecific_direct(k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_getspecific(k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> self;</span><br><span class="line">    <span class="type">void</span> *res;</span><br><span class="line">    <span class="keyword">if</span> ((key &gt;= <span class="number">1</span>) &amp;&amp; (key &lt;= _POSIX_THREAD_KEYS_MAX)) &#123;</span><br><span class="line">        self = pthread_self();</span><br><span class="line">        res = self-&gt;tsd[key<span class="number">-1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* Invalid key - no error, just NULL */</span></span><br><span class="line">        res = (<span class="type">void</span> *)<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是获得当前的队列的具体实现 <strong>_dispatch_queue_get_current</strong> 调用了 <strong>_dispatch_thread_getspecific</strong> 函数，在 <strong>_dispatch_thread_getspecific</strong> 函数中，当 <strong>_pthread</strong> 不存在直接的 <strong>tsd</strong> 数据时调用了函数 <strong>pthread_getspecific</strong>，然而该函数并未在 GCD 的库中，而是在 Libc 库的 pthreads(或是 libpthread) 中。</p>
<p><strong>pthread_self()</strong> 获得线程后，将 <strong>self-&gt;tsd[key-1]</strong> 赋值给 res 并返回，而 tsd 是一个指针数组，是线程的特定数据。当 <strong>pthread_getspecific</strong> 函数 return 后 <strong>_dispatch_thread_getspecific</strong> 将返回 <strong>dispatch_queue_t</strong> 类型的变量。至此，我们至少可以确定 GCD 队列和 pthread 有一定关系，然而到底具体是怎样的关系，我们可以通过查看线程的调用栈，来继续探索两者之间的关系。如下图，在 event handler 的回调被唤起时，设置断点，查看当前线程的调用栈。</p>
<p><img src="https://niyaoyao.github.io/images/apple-architecture-lldb-callstacksymbols.png" alt=""></p>
<p>在 GCD timer 回调的调用栈中，我们可以看到，虽然我们的队列名称一直是 “ny.monitor.queue” ，但是执行回调的线程却不一定相同。这是因为，并发队列是多个线程执行任务，而串行队列只有一个线程执行。比较特殊的就是主队列，只在主线程上执行任务。</p>
<p>除此之外，观察调用栈的函数调用顺序，先是调用 <strong>_start_wqthread</strong> 这个方法，之后调用 <strong>__pthread_wqthread</strong> 方法，然后，调用 <strong>_dispatch_worker_thread3</strong> 这个函数。那么接下来就具体看这几个函数实现。</p>
<p><strong>_start_wqthread</strong> 是汇编指令编写的代码，只有内核才会跳进这里的代码区域，然后调用 <strong>__pthread_wqthread</strong> 函数。 <strong>__pthread_wqthread</strong> 函数是内核队列的入口函数，继续看调用栈调用的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dispatch_worker_thread3(<span class="type">pthread_priority_t</span> pp) &#123;</span><br><span class="line">    <span class="type">bool</span> overcommit = pp &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> dq;</span><br><span class="line">    pp &amp;= _PTHREAD_PRIORITY_OVERCOMMIT_FLAG | ~_PTHREAD_PRIORITY_FLAGS_MASK;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_priority_key, (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)pp);</span><br><span class="line">    dq = _dispatch_get_root_queue_for_priority(pp, overcommit);</span><br><span class="line">    <span class="keyword">return</span> _dispatch_worker_thread4(dq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _dispatch_worker_thread4(<span class="type">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">    <span class="keyword">while</span> ((item = fastpath(_dispatch_queue_concurrent_drain_one(dq)))) &#123;</span><br><span class="line">        _dispatch_continuation_pop(item);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, <span class="literal">NULL</span>);</span><br><span class="line">    _dispatch_force_cache_cleanup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> * _<span class="title">dispatch_queue_concurrent_drain_one</span>(<span class="title">dispatch_queue_t</span> <span class="title">dq</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">head</span>, *<span class="title">next</span>, *<span class="title">const</span> <span class="title">mediator</span> =</span> (<span class="type">void</span> *)~<span class="number">0ul</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The mediator value acts both as a &quot;lock&quot; and a signal</span></span><br><span class="line">    head = dispatch_atomic_xchg(&amp;dq-&gt;dq_items_head, mediator);</span><br><span class="line">    <span class="comment">// 一些内存上的指针运算</span></span><br><span class="line">    _dispatch_queue_wakeup_global(dq);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> _dispatch_queue_wakeup_global(<span class="type">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_root_queue_context_s</span> *<span class="title">qc</span> =</span> dq-&gt;do_ctxt;</span><br><span class="line">    <span class="type">pthread_workitem_handle_t</span> wh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> gen_cnt;</span><br><span class="line">    <span class="type">pthread_t</span> pthr;</span><br><span class="line">    <span class="type">int</span> r, t_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<strong>_dispatch_worker_thread3</strong> 调用并返回 <strong>_dispatch_worker_thread4</strong>，<strong>_dispatch_worker_thread4</strong> 调用了 <strong>_dispatch_queue_concurrent_drain_one</strong>，最终调用了 <strong>_dispatch_queue_wakeup_global</strong>。 </p>
<p><strong>_dispatch_queue_wakeup_global</strong> 的函数体中，<strong>struct dispatch_root_queue_context_s *qc = dq-&gt;do_ctxt;</strong> 这句代码是将 dispatch queue 的 dispatch object 指向的 context 赋值给了 <strong>dispatch_root_queue_context_s</strong> 指针。</p>
<p>首先来看 <strong>dispatch_queue_t</strong> 是如何定义的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_DECL(name) typedef struct name##_s *name##_t;</span></span><br><span class="line">DISPATCH_DECL(dispatch_queue);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_STRUCT_HEADER(x, y)    \</span></span><br><span class="line"><span class="meta">    const struct y *do_vtable;  \</span></span><br><span class="line"><span class="meta">    struct x *volatile do_next; \</span></span><br><span class="line"><span class="meta">    unsigned int do_ref_cnt;    \</span></span><br><span class="line"><span class="meta">    unsigned int do_xref_cnt;   \</span></span><br><span class="line"><span class="meta">    unsigned int do_suspend_cnt;    \</span></span><br><span class="line"><span class="meta">    struct dispatch_queue_s *do_targetq;    \</span></span><br><span class="line"><span class="meta">    void *do_ctxt; \</span></span><br><span class="line"><span class="meta">    void *do_finalizer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    DISPATCH_STRUCT_HEADER(dispatch_queue_s, dispatch_queue_vtable_s);</span><br><span class="line">    DISPATCH_QUEUE_HEADER;</span><br><span class="line">    <span class="type">char</span> dq_label[DISPATCH_QUEUE_MIN_LABEL_SIZE];   <span class="comment">// must be last</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>DISPATCH_DECL(name)</strong> 函数就是将 <strong>name##_s</strong> 的名字的结构体 重定义为 <strong>*name##_t</strong> 的指针类型。而 <strong>DISPATCH_STRUCT_HEADER(x, y)</strong> 函数是在<strong>预处理</strong>阶段，将 <strong>dispatch_queue_s</strong> 结构体的宏定义的函数，替换成已经定义好的成员变量。所以，<strong>dispatch_queue_s</strong> 结构体就有了 <strong>do_ctxt</strong> 这个成员变量。</p>
<p>接下来看 <strong>dispatch_root_queue_context_s</strong> 结构体的定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_THREAD_COUNT 255</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_root_queue_context_s</span> &#123;</span></span><br><span class="line">    <span class="type">pthread_workqueue_t</span> dgq_kworkqueue;</span><br><span class="line">    <span class="type">uint32_t</span> dgq_pending;</span><br><span class="line">    <span class="type">uint32_t</span> dgq_thread_pool_size;</span><br><span class="line">    <span class="type">dispatch_semaphore_t</span> dgq_thread_mediator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  _<span class="title">pthread_workqueue</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>       sig;       <span class="comment">/* Unique signature for this structure */</span></span><br><span class="line">    <span class="type">pthread_lock_t</span> lock;          <span class="comment">/* Used for internal mutex on structure */</span></span><br><span class="line">    TAILQ_ENTRY(_pthread_workqueue) wq_list;    <span class="comment">/* workqueue list in prio */</span></span><br><span class="line">    TAILQ_HEAD(, _pthread_workitem) item_listhead;  <span class="comment">/* pthread_workitem list in prio */</span></span><br><span class="line">    TAILQ_HEAD(, _pthread_workitem) item_kernhead;  <span class="comment">/* pthread_workitem list in prio */</span></span><br><span class="line">    <span class="type">pthread_workqueue_head_t</span> headp;</span><br><span class="line">    <span class="comment">// 其他成员变量...</span></span><br><span class="line">&#125;  * <span class="type">pthread_workqueue_t</span>;</span><br></pre></td></tr></table></figure>
<p>从 <strong>dispatch_root_queue_context_s</strong> 结构体的定义中可以观察到，有一个成员变量 <strong>dgq_kworkqueue</strong> 是 <strong>pthread_workqueue_t</strong> 类型的。而 <strong>pthread_workqueue_t</strong> 类型是 BSD 层的工作队列类型。</p>
<p>也就是说，GCD 队列 <strong>dispatch_queue_t</strong> 的 <strong>dispatch_root_queue_context_s</strong> 类型的上下文成员变量 <strong>do_ctxt</strong>，其实就是 BSD 层的 <strong>pthread_workqueue_t</strong> 一层包装。</p>
<p>而在 <strong>_dispatch_queue_wakeup_global</strong> 的函数中，当 GCD 队列的上下文 <strong>do_ctxt</strong> 存在，并且 <strong>dgq_pending</strong> 的值改为 1 时，调用 <strong>pthread_workqueue_additem_np</strong> 函数，该函数会通知 XNU 层的 <strong>workqueue</strong> 增加相应执行的项目，根据该通知 XNU 内核基于系统状态判断是否要生成线程。</p>
<p>对于 GCD 队列，libdispatch-685 版的 GCD 队列类型如下。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS = <span class="number">0</span>,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_MAINTENANCE_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_UTILITY_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INITIATED_QOS_OVERCOMMIT,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS,</span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_USER_INTERACTIVE_QOS_OVERCOMMIT,</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_IDX_COUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>与上述枚举类型相对应的 GCD 队列 label 名称为：</p>
<ul>
<li><strong>com.apple.root.maintenance-qos</strong></li>
<li><strong>com.apple.root.maintenance-qos.overcommit</strong></li>
<li><strong>com.apple.root.background-qos</strong></li>
<li><strong>com.apple.root.background-qos.overcommit</strong></li>
<li><strong>com.apple.root.utility-qos</strong></li>
<li><strong>com.apple.root.utility-qos.overcommit</strong></li>
<li><strong>com.apple.root.default-qos</strong></li>
<li><strong>com.apple.root.default-qos.overcommit</strong></li>
<li><strong>com.apple.root.user-initiated-qos</strong></li>
<li><strong>com.apple.root.user-initiated-qos.overcommit</strong></li>
<li><strong>com.apple.root.user-interactive-qos</strong></li>
<li><strong>com.apple.root.user-interactive-qos.overcommit</strong></li>
</ul>
<p>从以上队列名称中，发现一个新词 qos，何为 QoS？苹果官方文档解释如下：</p>
<blockquote>
<p>A quality of service (QoS) class categorizes work to be performed on a DispatchQueue. By specifying a QoS to work, you indicate its importance, and the system prioritizes it and schedules it accordingly.</p>
</blockquote>
<p>QoS 类将工作事务在 GCD 队列上分类执行。通过具体说明将要工作的 QoS，开发者指明 QoS 的重要性，从而，系统令它具有更高优先级，并且相应地调度他。</p>
<p><img src="https://niyaoyao.github.io/images/gcd-queue.png" alt=""></p>
<p>上图很清晰地展示了 <strong>dispatch_queue_t</strong> 和 <strong>pthread_workqueue_t</strong> 的对应关系，则可知 GCD 队列除了对优先级 <strong>Priority</strong> 对队列进行区分，还会根据 <strong>Overcommit</strong> 的不同区分不同队列类型。</p>
<p><strong>Overcommit</strong> 级别就是 QoS 机制为用户提供指明队列优先级的类型。XNU 内核基于系统状态判断是否要生成线程，而对于 <strong>Overcommit</strong> 队列，不论操作系统多么繁忙，内核都会为之创建一个新的线程。</p>
<p><img src="https://www.objc.io/images/issue-2/gcd-queues@2x-82965db9.png" alt=""></p>
<p>上图展示了用户自定义队列、GCD 队列以及线程之间的对应关系。</p>
<p>GCD 暴露了五个不同的队列：运行在主线程的主队列，三个不同优先级的后台队列，以及一个拥有更低优先级被 I/O 限制的后台队列。除此之外，开发者可以创建串行或并发的自定义队列。自定义队列是一个强大的抽象的同时，开发人员在这些队列上调度的所有 block，最终缓缓流至系统的全局队列，以及他们的线程池。</p>
<p>我们已经了解到，GCD 队列和线程队列的关系，并且当 GCD 队列是 <strong>Overcommit</strong> 类型时，不论操作系统多么繁忙，内核都会为之创建一个新的线程。GCD 队列 <strong>dispatch_root_queue_context_s</strong> 的上下文变量中，有一个用来记录线程池大小的字段 <strong>dgq_thread_pool_size</strong>。而对于执行的任务来说，所执行的线程具体是哪个线程，则是通过 GCD 的线程池（Thread Pool）来进行调度。</p>
<p><strong>工作队列是 OS X/iOS 为应用程序提供多线程支持的一种机制</strong>，GCD 正是是基于这种机制进行设计的。此外，<strong>NSOperationQueue</strong> 是 GCD 队列模型的一种 Cocoa 抽象。与 GCD 提供低级别（编程语言层次）的控制不同，操作队列在此之上实现了一些便捷的特性，对应用开发者而言，是最佳且最安全的选择。</p>
<blockquote>
<p><strong>思维扩展</strong><br>我们通过研读 GCD 源码可以知道，GCD 是 Apple 公司用 C 语言编写的工作队列管理的开源库，调用了 pthread 相关方法，使得开发人员进行 CPU 线程调度、队列管理更加方便。那么，既然 GCD 是用 C 语言编写的，那能否在其他 OS 上进行移植呢？<br><del>答案是否定的。因为 GCD 是基于 mach 调用来编写的，而 mach 调用仅适用于 OS X/iOS 的 Darwin 内核，所以，虽然 GCD 非常好用，但却不能移植到 Linux/Windows 操作系统上。然而，遵从 POSIX 规范的 pthread 却可以跨平台开发。接下来就详细看一下 pthread 的相关内容。</del></p>
<p>十分感谢多弗朗明哥大神看完之后指出我的错误，大神原话：“GCD 是可以移植到其他平台，我用过 Windows 版本的，性能肯定没有 Darwin 内核的好（毕竟底层有优化支持 ），而且不支持 block，传的是函数指针。补充一下微软的 WinObjc 项目也内置了 GCD，还有支不支持 block 取决于编译器。”</p>
<p>再次感谢多弗朗明哥大神的校正，又学到新技能了，有时间再接触一下 Windows 版本的 GCD，这样一套 API 多平台都可以使用，那真真是极好的 :) 学习成本就低了。十分感谢大神赐教～ 😝</p>
</blockquote>
<h1 id="Thead"><a href="#Thead" class="headerlink" title="Thead"></a>Thead</h1><p>我们通过阅读 GCD 源码，已经搞清楚 GCD 队列和 pthread 队列的对应关系，也了解了 GCD 的队列和线程之间的关系。那么下面我们就来探究线程的具体实现原理。</p>
<h2 id="BSD-层的-pthread"><a href="#BSD-层的-pthread" class="headerlink" title="BSD 层的 pthread"></a>BSD 层的 pthread</h2><p>OS X/iOS 的基本架构上文已经提到，OS X/iOS 的核心是 Darwin，而 Darwin 的架构从上往下依次是用户态/内核态的转换、BSD 层、Mach 抽象层，最底层是硬件相关接口。而 BSD 层建立在 Mach 抽象层之上，并提供了 POSIX 接口，以及一些 BSD 的系统调用。</p>
<p>首先，我们来了解什么是 POSIX。Wikipedia 的解释如下。</p>
<blockquote>
<p>The Portable Operating System Interface (POSIX) is a family of standards specified by the IEEE Computer Society for maintaining compatibility between operating systems. POSIX defines the application programming interface (API), along with command line shells and utility interfaces, for software compatibility with variants of Unix and other operating systems.</p>
</blockquote>
<p>可移植操作系统接口（POSIX）是由 IEEE 计算机学会指定的用于维护操作系统之间兼容性的一系列标准。 POSIX 定义了应用程序编程接口（API）以及命令行shell和实用程序接口，用于与 Unix 和其他操作系统的变体进行软件兼容。</p>
<p>以 <strong>pthread</strong> 为例， <strong>pthread</strong> 的相关方法，不光可以在 Linux 操作系统上调用，还可以在 OS X 和 Windows 操作系统上调用。比如创建线程，都是调用 <strong>pthread_create</strong> 函数，这对于 Linux/OS X/Windows 其实是一致的。</p>
<p>然而，对于不同 OS 而言，<strong>pthread</strong> 的具体封装并不相同，就 OS X 而言，BSD 层暴露的 POSIX 接口，其实都是 Mach 抽象层的再次封装。下面就具体探讨 <strong>pthread</strong> 和 Mach 抽象层的 thread 的关系。<br><strong>pthread</strong> 类型是在 Libc 库的 <strong>pthread_internals.h</strong> 文件中定义的。如下代码是采用 Libc-498.1.7 的源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pthread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span>           sig;       <span class="comment">/* Unique signature for this structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">darwin_pthread_handler_rec</span> *__<span class="title">cleanup_stack</span>;</span></span><br><span class="line">    <span class="type">pthread_lock_t</span> lock;          <span class="comment">/* Used for internal mutex on structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_mutex</span> *<span class="title">mutexes</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pthread</span> *<span class="title">joiner</span>;</span></span><br><span class="line">    <span class="type">void</span>           *exit_value;</span><br><span class="line">    <span class="type">semaphore_t</span>    death;       <span class="comment">/* pthread_join() uses this to wait for death&#x27;s call */</span></span><br><span class="line">    <span class="type">mach_port_t</span>    kernel_thread; <span class="comment">/* kernel thread this thread is bound to */</span></span><br><span class="line">    <span class="type">void</span>           *(*fun)(<span class="type">void</span>*);<span class="comment">/* Thread start routine */</span></span><br><span class="line">    <span class="type">int</span>        cancel_state;  <span class="comment">/* Whether thread can be cancelled */</span></span><br><span class="line">    <span class="type">int</span>        err_no;      <span class="comment">/* thread-local errno */</span></span><br><span class="line">    <span class="type">void</span>           *tsd[_EXTERNAL_POSIX_THREAD_KEYS_MAX + _INTERNAL_POSIX_THREAD_KEYS_MAX];  <span class="comment">/* Thread specific data */</span></span><br><span class="line">    <span class="type">size_t</span>         stacksize;      <span class="comment">/* Size of the stack (is a multiple of vm_page_size and &gt;= PTHREAD_STACK_MIN) */</span></span><br><span class="line">    <span class="type">mach_port_t</span>    reply_port;     <span class="comment">/* Cached MiG reply port */</span></span><br><span class="line">    <span class="type">void</span>           *cthread_self;  <span class="comment">/* cthread_self() if somebody calls cthread_set_self() */</span></span><br><span class="line">    <span class="comment">/* protected by list lock */</span></span><br><span class="line">    <span class="type">mach_port_t</span> joiner_notify;</span><br><span class="line">    <span class="type">char</span>    pthread_name[<span class="number">64</span>];       <span class="comment">/* including nulll the name */</span></span><br><span class="line">        <span class="type">int</span> max_tsd_key;</span><br><span class="line">    <span class="type">void</span> *  cur_workq;</span><br><span class="line">    <span class="type">void</span> * cur_workitem;</span><br><span class="line">    <span class="comment">// some other code...</span></span><br><span class="line">&#125; *<span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码，就是 <strong>pthread</strong> 在 Libc-498.1.7 的 <strong>pthread_internals.h</strong> 文件中的定义。在定义中，我们可以看到 <strong>mach_port_t</strong> 类型的成员变量。<strong>mach_port_t</strong> 类型实际上就是 <strong>unsigned int</strong> 重定义类型，是一个已经命名的端口权限。比如，<strong>kernel_thread</strong> 就是内核线程与 BSD 层的线程绑定的端口。</p>
<p>在 Mach 中，进程、线程和虚拟内存都是对象，所有的对象都有自己的属性。Mach 通过消息 <strong>mach_msg()</strong> 传递的方式实现对象和对象之间的通信，消息在端口 <strong>mach_port_t</strong> 之间传递。所有的 Mach 原生对象都是通过对应的端口访问的。</p>
<p><img src="https://niyaoyao.github.io/images/system_call.png" alt=""></p>
<p>比如，下面的代码提供了获得当前主机可用的内存大小的方法。若想要获取内存当前可使用量，就必须先得到当前主机对象 host 的端口 mach_host_self()，之后再向对象发送消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_free_memory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">mach_port_t</span> host = mach_host_self();</span><br><span class="line">    <span class="type">mach_msg_type_number_t</span> size = <span class="keyword">sizeof</span>(<span class="type">vm_statistics_data_t</span>) / <span class="keyword">sizeof</span>(<span class="type">integer_t</span>);</span><br><span class="line">    <span class="type">vm_size_t</span> pagesize;</span><br><span class="line">    <span class="type">vm_statistics_data_t</span> vmstat;</span><br><span class="line">    host_page_size(host, &amp;pagesize);</span><br><span class="line">    host_statistics(host, HOST_VM_INFO, (<span class="type">host_info_t</span>)&amp;vmstat, &amp;size);</span><br><span class="line">    <span class="keyword">return</span> vmstat.free_count * pagesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mach-thread-与-pthread-的关系"><a href="#Mach-thread-与-pthread-的关系" class="headerlink" title="Mach thread 与 pthread 的关系"></a>Mach thread 与 pthread 的关系</h2><p>上一节我们已经对 <strong>pthread</strong> 有所了解，对于 <strong>pthread</strong> 是如何在 Mach 层上对线程进行封装的就暂不细究，下面简单来看一下，对于 XNU 而言，线程是如何创建的，从而也可以看出 <strong>pthread</strong> 和 Mach 抽象层 <strong>thread</strong> 是怎样的关系。</p>
<p><img src="https://niyaoyao.github.io/images/flow-of-thread-creation.png" alt=""></p>
<p>用户态的调用开始于 <strong>pthread_create</strong> 的调用。这个函数做的工作并不多，因为主要工作是由 <strong>bsdthread_create</strong> 系统调用完成的，这个系统调用的实现是在 <strong>bsd/kern/pthread_synch.c</strong> 文件中。<strong>bsdthread_create()</strong> 只不过是对 Mach 线程创建的复杂包装。真正的线程创建是由底层 Mach 层完成的。<strong>bsdthread_create()</strong>负责的工作是设置线程栈（如果指定了自定义栈），设置机器相关的线程状态，以及设置自定义调度参数等。</p>
<h1 id="Run-Loop"><a href="#Run-Loop" class="headerlink" title="Run Loop"></a>Run Loop</h1><p>开篇场景的疑问已经解决了：三个进程和线程的基本概念、GCD 队列和线程的关系，以及线程在 BSD 层和 Mach 抽象的的定义和关系，下面就来继续探究 Run Loop 相关技术原理。</p>
<p>对于本文中的场景，假设我们不用 Run Loop 去开启循环，而是直接用 While 循环调用 CPU 和 Memory 的函数，虽然依旧可以保证主线程不结束，但会导致 CPU 使用率飙升，因而，Apple 提供了 CFRunLoop 来优化应用程序的运行循环。</p>
<p>那么，同样是循环，那这个循环的具体代码在哪里？Run Loop与线程有怎样的关系？带着疑问开始探究。</p>
<h2 id="NSRunLoop-与-CFRunLoop"><a href="#NSRunLoop-与-CFRunLoop" class="headerlink" title="NSRunLoop 与 CFRunLoop"></a>NSRunLoop 与 CFRunLoop</h2><p>为了让 Command Line 的主线程能够常驻，在开篇代码的 <strong>dispatch_resume(timer)</strong> 后面调用了 <strong>[[NSRunLoop currentRunLoop] run]</strong>，从而开启运行循环。 <strong>NSRunLoop</strong> 并不是开源的，Apple 暴露了头文件，可以简单看一下 <strong>NSRunLoop</strong> 相关属性和方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">NSDefaultRunLoopMode</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSRunLoopMode</span> <span class="keyword">const</span> <span class="built_in">NSRunLoopCommonModes</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSRunLoop</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="type">id</span>          _rl;</span><br><span class="line">    <span class="type">id</span>          _dperf;</span><br><span class="line">    <span class="type">id</span>          _perft;</span><br><span class="line">    <span class="type">id</span>          _info;</span><br><span class="line">    <span class="type">id</span>      _ports;</span><br><span class="line">    <span class="type">void</span>    *_reserved[<span class="number">6</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSRunLoop</span> *currentRunLoop;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSRunLoop</span> *mainRunLoop <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSRunLoopMode</span> currentMode;</span><br><span class="line">- (<span class="built_in">CFRunLoopRef</span>)getCFRunLoop <span class="built_in">CF_RETURNS_NOT_RETAINED</span>;</span><br><span class="line">- (<span class="type">void</span>)addTimer:(<span class="built_in">NSTimer</span> *)timer forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line">- (<span class="type">void</span>)addPort:(<span class="built_in">NSPort</span> *)aPort forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line">- (<span class="type">void</span>)removePort:(<span class="built_in">NSPort</span> *)aPort forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDate</span> *)limitDateForMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line">- (<span class="type">void</span>)acceptInputForMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSRunLoop</span> (<span class="title">NSRunLoopConveniences</span>)</span></span><br><span class="line">- (<span class="type">void</span>)run; </span><br><span class="line">- (<span class="type">void</span>)runUntilDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line">- (<span class="type">BOOL</span>)runMode:(<span class="built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>
<p>在 NSRunLoop 的方法中，提供了一个获取当前 <strong>CFRunLoop</strong> 的方法 <strong>getCFRunLoop</strong>，点击 Pause program execution 按钮，暂停主线程执行的任务，添加 <strong>[NSRunLoop currentRunLoop]</strong> 观察对象。</p>
<p><img src="https://niyaoyao.github.io/images/nsthread-callstacksymbols.png" alt=""></p>
<p><strong>[NSRunLoop currentRunLoop]</strong> 的私有属性 <strong>_rl</strong> 的内存地址，与控制台输出的 <strong>CFRunLoop</strong> 的内存地址相同，都是 <strong>0x100406f40</strong>。所以，我们可以确定私有属性 <strong>_rl</strong> 就是 [<strong>NSRunLoop currentRunLoop]</strong> 所引用的 <strong>CFRunLoop</strong> 对象。从而可知 <strong>NSRunLoop</strong> 是基于 <strong>CFRunLoop</strong> 的封装。</p>
<p><strong>NSRunLoop</strong> 类并不是线程安全的，如果开发者使用 <strong>NSRunLoop</strong> 类修改 Run Loop ，那么只能从拥有 Run Loop 的同一线程执行此操作。将输入源或计时器添加到属于不同线程的运行循环，可能会导致代码以意想不到的方式崩溃或表现。</p>
<h2 id="CFRunLoop-相关-API"><a href="#CFRunLoop-相关-API" class="headerlink" title="CFRunLoop 相关 API"></a>CFRunLoop 相关 API</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;          <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    __CFPort _wakeUpPort;           <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    <span class="type">pthread_t</span> _pthread;</span><br><span class="line">    <span class="type">uint32_t</span> _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></span><br></pre></td></tr></table></figure>
<p>上述代码是 CF-1153.18 CFRunLoop.c 文件中 <strong>__CFRunLoop</strong> 的定义。由 <strong>__CFRunLoop</strong> 的定义中可以观察到存在 <strong>pthread_t</strong> 类型的 <strong>_pthread</strong> 成员变量，表明线程和 <strong>RunLoop</strong> 之间是一一对应的关系，<strong>RunLoop</strong> 引用了 <strong>_pthread</strong> 指针，所以在使用 <strong>RunLoop</strong> 时需要注意释放线程对象，避免引起内存的循环引用。</p>
<p>另外， <strong>__CFRunLoop</strong> 的结构体存在 <strong>CFRunLoopModeRef</strong> 类型的 <strong>_currentMode</strong> 成员变量，而 <strong>CFRunLoopModeRef</strong> 的引用类型是 <strong>__CFRunLoopMode</strong> 的指针变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;  <span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="type">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="type">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="type">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="type">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    <span class="type">void</span> (*_msgPump)(<span class="type">void</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    <span class="type">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从 <strong>__CFRunLoopMode</strong> 结构体定义中，可以观察到有这样几个比较重要的字段，<strong>CFMutableSetRef</strong> 集合类型的 <strong>_sources0</strong> 和 <strong>_sources1</strong>，<strong>CFMutableArrayRef</strong> 数组类型的 <strong>_observers</strong> 和 <strong>_timers</strong>。</p>
<p>由此，我们可以得出如下的对应关系图。</p>
<p><img src="https://niyaoyao.github.io/images/runloop.png" alt=""></p>
<p>如上图所示， <strong>RunLoop 和 Thread 是一一对应的关系，RunLoop 和 RunLoop Mode 是一对多的关系。RunLoop Mode 分别和 RunLoop Observer 、RunLoop Timer、RunLoop Source 是一对多的关系。并且 RunLoop Source 分为 Source0 和 Source1 两种类型。</strong></p>
<p>在 CFRunLoop.h 文件中对外开放了 <strong>CFRunLoopRef</strong>、<strong>CFRunLoopSourceRef</strong>、<strong>CFRunLoopObserverRef</strong>、<strong>CFRunLoopTimerRef</strong> 这几个类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> * <span class="title">CFRunLoopSourceRef</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> * <span class="title">CFRunLoopObserverRef</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CF_BRIDGED_MUTABLE_TYPE(T)  __attribute__((objc_bridge_mutable(T)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">CF_BRIDGED_MUTABLE_TYPE</span><span class="params">(NSTimer)</span> __CFRunLoopTimer * CFRunLoopTimerRef;</span><br></pre></td></tr></table></figure>
<p>那接下来就分别来看一下如何使用这些类型。</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>观察者 <strong>CFRunLoopObserverRef</strong> 在运行循环本身的执行期间，会在特殊活动状态时触发，比如，休眠、唤醒等状态。所以，观察者常应用于 App 的实时卡顿监控。这里就简单介绍一个创建观察者的例子，来了解 <strong>CFRunLoopObserverRef</strong> 相关 API 的使用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)threadMain &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> myRunLoopRef = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, <span class="built_in">CFBridgingRetain</span>(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;MyRunLoopObserver, &amp;context);</span><br><span class="line">        <span class="keyword">if</span> (observer) &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRef</span> cfLoop = myRunLoopRef;</span><br><span class="line">            <span class="built_in">CFRunLoopAddObserver</span>(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(show) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        <span class="built_in">NSInteger</span> loopCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">5</span>]];</span><br><span class="line">            loopCount--;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;LoopCount : %lu&quot;</span>, loopCount);</span><br><span class="line">        &#125; <span class="keyword">while</span> (loopCount);</span><br><span class="line">        <span class="comment">// [timer invalidate];</span></span><br><span class="line">        <span class="comment">//timer = nil;</span></span><br><span class="line">        printf(<span class="string">&quot;myRunLoopRef: %p\n&quot;</span>, myRunLoopRef);</span><br><span class="line">        printf(<span class="string">&quot;CFRunLoopGetCurrent: %p\n&quot;</span>, <span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">        <span class="built_in">CFRunLoopStop</span>(myRunLoopRef);</span><br><span class="line">        printf(<span class="string">&quot;timer: %p\n&quot;</span>, timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建一个 <strong>RunLoopManager</strong> 类，并实现 <strong>threadMain</strong> 方法，在 <strong>threadMain* 方法实现中，创建观察者，并实现观察者的回调函数 </strong>MyRunLoopObserver**。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> MyRunLoopObserver(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="type">void</span>* info) &#123;</span><br><span class="line">    <span class="comment">// Perform your tasks here.</span></span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop 进入&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;即将处理 Timer&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;即将处理 Input Sources&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;即将睡眠&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;从睡眠中唤醒,处理完唤醒源之前&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后向当前的 <strong>RunLoop</strong> 中添加 <strong>CFRunLoopObserverRef</strong> 的观察者。然后创建 <strong>NSTimer</strong> 并每秒处发一次 <strong>show</strong> 方法。创建一个 do-while 循环，使得每隔 5 秒就重新启动 <strong>RunLoop</strong> 直到 <strong>loopCount</strong> 变为 0 时停止。</p>
<p>代码编写好之后，编译运行。当 <strong>threadMain</strong> 在后台线程调用时，每秒都会出发 <strong>Timer</strong> 的方法，同时也会触发 <strong>CFRunLoopObserverRef</strong> 的回调函数，从而输出 RunLoop 的不同活跃状态。直到 loopCount 变为 0 时停止 RunLoop。当 RunLoop 停止时，NSTimer 的定时器也就停止了。</p>
<p>由上文 CFRunLoop.h 开放的类型声明中可以得知， <strong>NSTimer</strong> 和 <strong>CFRunLoopTimerRef</strong> 是 <strong>toll-free bridged</strong> 的关系，两者可以混用。<strong>NSTimer 不是实时机制(real-time mechanism)</strong>，只有添加了 timer 的 RunLoop 已经启动，并且能够检查定时器时间是否已经成为过去时，timer 才会被触发。</p>
<p>此外，当这段代码运行在主线程时，就不是上面的结果。而是控制台会一直输出 Timer 方法和 <strong>CFRunLoopObserverRef</strong> 的回调函数中打印的内容，不会停止当前的运行循环，也不会终止 Timer。也就是说 <strong>CFRunLoopStop(runloop)</strong> 函数对于主线程不起作用，不过假如起作用的话，那程序就顺序执行完 return 了，App 就不能正常运行了。</p>
<p>所以，基于 <strong>RunLoop</strong> 的 Timer 并不可靠。比如，如果在 TableView 滚动时，<strong>RunLoop</strong> 的 <strong>Mode</strong> 就由 <strong>NSDefaultRunLoopMode</strong> 变为 <strong>UITrackingRunLoopMode</strong>，必须手动将 NSTimer 的定时器添加到 <strong>NSRunLoopCommonModes</strong> 模式中，才能保证 Timer 正常触发。</p>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>上文已经了解 <strong>NSTimer</strong> 是基于 <strong>RunLoop</strong> 的，并且可以和 <strong>CFRunLoopTimerRef</strong> 混用。所以，从另一个角度来说，<strong>RunLoop</strong> 也会引用应用程序中活跃状态的 <strong>Timer</strong>，很有可能造成内存的引用循环从而导致内存泄漏。但是作为学习而言，还是可以了解一下 <strong>CFRunLoopTimerRef</strong> 是如何创建的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        &amp;myCFTimerCallback, &amp;context);</span><br><span class="line">CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>思维扩展</strong><br>CFRunLoopTimerRef 与 GCD Timer 的区别。<br>在上文中，我们已经了解到 GCD Timer 是利用 GCD Source 创建的，而 GCD Source 回调事件的执行，是内核态跳进 _start_wqthread 之后调用 __pthread_wqthread 方法最后唤起回调函数，并不依赖于 RunLoop。所以，当 RunLoop 的 Mode 改变或结束时，GCD Timer 也不会暂停或停止。而 NSTimer/CFRunLoopTimerRef 创建的 Timer 则会受 RunLoop 影响，从而丧失定时器的准确性。</p>
</blockquote>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>输入源与线程异步传递事件。事件的来源取决于输入源的类型，通常是两个类型，基于端口的输入源（Port-Based Sources）监视应用程序的 Mach 端口，自定义输入源（Custom Input Sources）监视自定义的事件源。</p>
<p>除了基于端口的源之外，Cocoa 还定义了一个自定义输入源，允许开发者在任何线程上执行选择器，比如，</p>
<ul>
<li><strong>performSelectorOnMainThread:withObject:waitUntilDone:</strong></li>
<li><strong>performSelector:onThread:withObject:waitUntilDone:</strong> 等。</li>
</ul>
<p>自定义源的创建（Custom Input Sources）及使用，如下面源码所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFRunLoopSourceRef runLoopSource;</span><br><span class="line">CFRunLoopSourceContext    context = &#123;<span class="number">0</span>, self, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                        &amp;RunLoopSourceScheduleRoutine,</span><br><span class="line">                                        RunLoopSourceCancelRoutine,</span><br><span class="line">                                        RunLoopSourcePerformRoutine&#125;;</span><br><span class="line"> </span><br><span class="line">runLoopSource = CFRunLoopSourceCreate(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;context);</span><br><span class="line">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line"><span class="comment">// Signaling the Input Source</span></span><br><span class="line">CFRunLoopSourceSignal(runLoopSource);</span><br><span class="line">CFRunLoopWakeUp(runloop);</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a>CFRunLoopRun</h3><p>通过前文的探究，我们已经知道 <strong>RunLoop</strong> 是通过调用 <strong>CFRunLoopRun(void)</strong> 函数来开启当前线程的运行循环的。那么接下来就详细来看 <strong>CFRunLoopRun(void)</strong> 的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CFRunLoopRun</span><span class="params">(<span class="type">void</span>)</span> &#123;   <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="type">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line">SInt32 <span class="title function_">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CFRunLoopRun(void)</strong> 函数体中，通过 <strong>do-while</strong> 判断 <strong>RunLoop</strong> 是否停止且是否结束来循环调用 <strong>CFRunLoopRunSpecific</strong> 函数， <strong>CFRunLoopRunSpecific</strong> 函数中先调用 <strong>__CFRunLoopDoObservers</strong> 通知 <strong>Observers</strong>，<strong>RunLoop</strong> 即将进入循环，然后调用 <strong>__CFRunLoopRun</strong> 进入内部循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0ULL</span> == timeout_context-&gt;termTSR);</span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) </span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) </span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">        &#125; </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入内部循环后，先通知观察者即将触发 Timer 回调，之后通知观察者即将触发 Source0 (非 Port-Based Sources)回调，执行被加入的回调 block。如果有 Source1 (Port-Based Sources) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。<br>通知观察者 RunLoop 的线程即将进入休眠(sleep)。调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠，直到被 Port-Based Sources 事件、定时器时间到，RunLoop 超时等事件唤醒。</p>
<p>RunLoop 的线程被唤醒后，通知观察者 RunLoop 的线程被唤醒了。如果一个 Timer 到时间了，那么触发这个 Timer 的回调。如果有 GCD 主队列的 block，执行 block。如果有 Source1 (Port-Based Sources) 发出事件，则处理该事件。如果 RunLoop 没超时，Mode 不为空，循环也没被停止，那继续循环。直到不满足条件，通知观察者 RunLoop 即将退出。</p>
<p>可以结合上文中 <strong>CFRunLoopObserverRef</strong> 创建 RunLoop 观察者的例子结合来理解 RunLoop 的不同状态的转换。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文是由一个实际场景为线索，展开了对进程、线程、 GCD 实现原理以及 Run Loop 实现原理等相关技术的探究。本文内容较多，对内容进行凝练概括，主要有以下几点。</p>
<ul>
<li><strong>一个进程是一个正被执行中的程序，与程序不同，一个进程是一个在内存中活跃的实体。</strong></li>
<li><strong>一个线程是一组寄存器的状态。</strong></li>
<li>操作系统解决内存（RAM）资源竞争的方式是分页（Paging）。</li>
<li>操作系统解决 CPU 资源竞争的方式是调度（Scheduling）。</li>
<li><strong>工作队列是 OS X/iOS 为应用程序提供多线程支持的一种机制，是 GCD 的基础机制。</strong></li>
<li>GCD 队列和 pthread 队列以及 BSD 层的工作队列存在对应关系。GCD 队列根据 Priority 和 Overcommit 的不同区分不同队列类型。而对于 Overcommit 队列，不论操作系统多么繁忙，内核都会为之创建一个新的线程。GCD 队列的线程由 <strong>GCD 线程池（Thread Pool）</strong>来调度。</li>
<li><strong>RunLoop 和 Thread 是一一对应的关系，RunLoop 和 RunLoop Mode 是一对多的关系。RunLoop Mode 分别和 RunLoop Observer 、RunLoop Timer、RunLoop Source 是一对多的关系。并且 RunLoop Source 分为 Source0 和 Source1 两种类型。</strong></li>
<li>观察者 CFRunLoopObserverRef 在运行循环本身的执行期间，会在特殊活动状态时触发，比如，休眠、唤醒等状态，可以根据这一特性进行 iOS 实时卡顿监控。</li>
<li>NSTimer 和 CFRunLoopTimerRef 是 toll-free bridged 的关系，两者可以混用，但由于 NSTimer 是基于 RunLoop 的，其所创建的定时器并不可靠。相对而言，GCD Timer 不依赖于 RunLoop，相对而言更加可靠，易用。</li>
<li>事件的来源取决于输入源的类型，通常是 Port-Based Sources 和 Custom Input Sources 两个类型。基于端口的输入源（Port-Based Sources）监视应用程序的 Mach 端口，自定义输入源（Custom Input Sources）监视自定义的事件源。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述，线程在物理上实际上是指一组 CPU 寄存器的状态，操作系统可以利用线程对程序要执行的任务进行调度。所以，Mach 抽象层（OS X 的内核 Darwin 的底层）就封装了 thread 这个类型，而在 BSD 层提供了 POSIX 的 pthread 接口，pthread 是 Mach thread 的一层封装。</p>
<p>Apple 公司提供了一种工作队列的机制用于任务调度，GCD 正是基于这种工作队列的机制研发的。GCD 提供了更方便的 API 用于调度任务，GCD 的主队列的任务在主线程上执行，其他 GCD 队列的线程则是由 GCD 的线程池管理的，这样开发者就不需要关心线程怎么分配任务，而只关心在哪个队列上执行怎样的任务，以及怎样执行任务（同步/异步）。</p>
<p>RunLoop 是保证不损耗 CPU 性能的前提下，利用事件循环（Event Loop）模式设计的一种让线程能随时处理事件但并不退出的循环。RunLoop 与线程实体（pthread）的关系是一一对应的，也会强引用线程对象（指针）。RunLoop 有多种 Mode，每种 Mode 对应多个 Source、Observer 和 Timer。</p>
<p>Source 是事件输入源（Input Sources），分为基于端口的源（Port-Based Sources）和自定义源（Custom Input Sources）。除了基于端口的源之外，Cocoa 还定义了一个自定义输入源，允许开发者在任何线程上执行选择器，比如，performSelectorOnMainThread:withObject:waitUntilDone:，performSelector:onThread:withObject:waitUntilDone: 等方法。</p>
<p>Observer 会在 RunLoop 的特定时刻被触发，可以根据这一特性进行 iOS 实时卡顿监控。</p>
<p>NSTimer 和 CFRunLoopTimerRef 是 toll-free bridged 的关系，两者可以混用，但由于 NSTimer 是基于 RunLoop 的，其所创建的定时器并不可靠。</p>
<h1 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h1><h2 id="本文案例源码"><a href="#本文案例源码" class="headerlink" title="本文案例源码"></a>本文案例源码</h2><p>十分感谢您能读到这，这篇文章比较偏低层原理。本文最初的 GCD 场景，是源于我想做一个系统资源的 Monitor 程序。而在解决场景问题，探究线程的过程中，我也学到了不少 mach 原语、mach 消息、mach 端口等相关技术。放上本文的案例源码，如果感兴趣可以看一下。<br>源码地址：<a target="_blank" rel="noopener" href="https://github.com/niyaoyao/performance-monitor">https://github.com/niyaoyao/performance-monitor</a></p>
<h2 id="Apple-Opensource-查阅指南"><a href="#Apple-Opensource-查阅指南" class="headerlink" title="Apple Opensource 查阅指南"></a>Apple Opensource 查阅指南</h2><p>Apple Opensource 的主页链接为 <a target="_blank" rel="noopener" href="https://opensource.apple.com">https://opensource.apple.com</a> 。一开始笔者学习 Apple Opensource 无从下手，久了就发现个小规律，如下所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>描述</th>
<th>下载包链接</th>
<th>在线源码链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>源码包和在线源码</td>
<td><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/">https://opensource.apple.com/tarballs/</a></td>
<td><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/">https://opensource.apple.com/source/</a></td>
</tr>
<tr>
<td>GCD 相关源码</td>
<td><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">https://opensource.apple.com/tarballs/libdispatch/</a></td>
<td><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/libdispatch/">https://opensource.apple.com/source/libdispatch/</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="源码说明"><a href="#源码说明" class="headerlink" title="源码说明"></a>源码说明</h2><p>由于单一版本具体函数的实现不全，因而，笔者结合不同版本的源码来进行原理的探究。</p>
<ul>
<li>本文中所使用的 GCD 源码，采用 libdispatch-84.5 和 libdispatch-685 版本，大部分基于 libdispatch-84.5。</li>
<li>XNU 内核代码采用 xnu-792、xnu-1456.1.26 和 xnu-3789.51.2。</li>
<li>Libc 源码采用 Libc-498.1.7、Libc-1158.50.2。</li>
<li>Core Foundation 源码采用 CF-299，CF-1152.14，CF-1153.18。</li>
</ul>
<p>本文如有任何错误或问题欢迎到<a target="_blank" rel="noopener" href="https://github.com/niyaoyao/niyaoyao.github.io/issues/new">这里</a> 提 issue，一起交流学习，共同进步成长 😊。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《Mac OS X and iOS Internals: To the Apple’s Core》</li>
<li>《OS X and iOS Kernel Programming》</li>
<li>《High Performance iOS Apps》</li>
<li>《Objective-C 高级编程 —— iOS 与 OS X 多线程和内存管理》</li>
<li>Concurrent Programming: APIs and Challenges <a target="_blank" rel="noopener" href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/">https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/</a></li>
<li>Threading Programming Guide——Run Loops <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></li>
<li>iOS线下分享《RunLoop》by 孙源@sunnyxx <a target="_blank" rel="noopener" href="http://v.youku.com/v_show/id_XODgxODkzODI0.html?refer=pc-sns-1&amp;spm=a2h0j.8191426.0.0">http://v.youku.com/v_show/id_XODgxODkzODI0.html?refer=pc-sns-1&amp;spm=a2h0j.8191426.0.0</a></li>
<li>深入理解 RunLoop（ibireme） <a target="_blank" rel="noopener" href="http://blog.ibireme.com/2015/05/18/runloop/">http://blog.ibireme.com/2015/05/18/runloop/</a></li>
<li>深入理解 RunLoop(独奏) <a target="_blank" rel="noopener" href="http://honglu.me/2017/03/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop/">http://honglu.me/2017/03/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop/</a></li>
<li>POSIX_Threads Wiki <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/POSIX_Threads">https://en.wikipedia.org/wiki/POSIX_Threads</a></li>
<li>Thread_pool <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_pool">https://en.wikipedia.org/wiki/Thread_pool</a></li>
<li>Quality of Service（QoS） <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/dispatch/dispatchqos">https://developer.apple.com/reference/dispatch/dispatchqos</a></li>
</ul>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/05/09/reverse-d4/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/10/03/docker-go/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: 'e929305d1df52067f223',
  clientSecret: '465557188fddc6608846e97927bc2fe7a268f141',
  repo: 'blog-comments',
  owner: 'niyaoyao',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['niyaoyao'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
