<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>iOS 基础面试题 | N.Y.</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="interview," />
  

  <meta name="description" content="以下是一套系统的 Swift 面试题整理，涵盖核心语法、多线程编程、内存管理及主流框架，问题按模块分类并附详细解答：  一、Struct 与 Class 深度对比 1. 核心区别  值类型 vs 引用类型：struct 是值类型（栈内存），class 是引用类型（堆内存） 继承：class 支持继承，struct 不支持 内存管理：class 需要手动处理引用计数（ARC），struct 无需 线">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 基础面试题">
<meta property="og:url" content="http://niyaoyao.me/2025/06/09/interview/index.html">
<meta property="og:site_name" content="N.Y.">
<meta property="og:description" content="以下是一套系统的 Swift 面试题整理，涵盖核心语法、多线程编程、内存管理及主流框架，问题按模块分类并附详细解答：  一、Struct 与 Class 深度对比 1. 核心区别  值类型 vs 引用类型：struct 是值类型（栈内存），class 是引用类型（堆内存） 继承：class 支持继承，struct 不支持 内存管理：class 需要手动处理引用计数（ARC），struct 无需 线">
<meta property="og:locale">
<meta property="article:published_time" content="2025-06-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-09T13:07:26.538Z">
<meta property="article:author" content="Niyao">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico/images/avatar_ny.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">Hi~</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">Hi~</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Struct-%E4%B8%8E-Class-%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="toc-text">一、Struct 与 Class 深度对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-text">1. 核心区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2. 初始化注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Codable-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98"><span class="toc-text">二、Codable 协议实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Class-%E6%94%AF%E6%8C%81-Codable"><span class="toc-text">1. Class 支持 Codable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E6%AE%B5%E5%85%BC%E5%AE%B9%E6%8A%80%E5%B7%A7"><span class="toc-text">2. 字段兼容技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Optional-%E6%9C%AC%E8%B4%A8%E5%89%96%E6%9E%90"><span class="toc-text">三、Optional 本质剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">四、多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GCD-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">1. GCD 核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-async-await-Swift-Concurrency"><span class="toc-text">2. async&#x2F;await (Swift Concurrency)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Swift-%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95"><span class="toc-text">五、Swift 核心语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Protocol-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-text">1. Protocol 高级用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">2. 泛型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%AD%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-text">3. 闭包管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88ARC%EF%BC%89"><span class="toc-text">六、内存管理（ARC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">1. 循环引用解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-text">七、响应式编程框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Combine-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">1. Combine 核心组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-RxSwift-%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">2. RxSwift 核心操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%A2%91%E8%BF%9B%E9%98%B6%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">高频进阶面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-iOS-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88Objective-C-Swift%EF%BC%89"><span class="toc-text">📌 iOS 基础面试题（Objective-C + Swift）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Objective-C-%E5%9F%BA%E7%A1%80"><span class="toc-text">一、Objective-C 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">1. 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Runtime"><span class="toc-text">2. Runtime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">3. 多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">4. 设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Swift-%E5%9F%BA%E7%A1%80"><span class="toc-text">二、Swift 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-struct-vs-class"><span class="toc-text">1. struct vs class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Optional"><span class="toc-text">2. Optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%8F%E8%AE%AE-%E6%B3%9B%E5%9E%8B"><span class="toc-text">3. 协议 &amp; 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%97%AD%E5%8C%85"><span class="toc-text">4. 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88Swift%EF%BC%89"><span class="toc-text">5. 多线程（Swift）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Codable"><span class="toc-text">6. Codable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88Swift%EF%BC%89"><span class="toc-text">7. 内存管理（Swift）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">8. 响应式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81iOS-%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-text">三、iOS 开发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-UI-%E5%8A%A8%E7%94%BB"><span class="toc-text">1. UI &amp; 动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C"><span class="toc-text">2. 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">3. 数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">4. 性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9E%B6%E6%9E%84-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">5. 架构 &amp; 设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E9%AB%98%E9%A2%91-Swift-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">📌 高频 Swift 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-struct-vs-class-2"><span class="toc-text">1. struct vs class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Codable"><span class="toc-text">2. Codable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B-2"><span class="toc-text">3. 多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">4. 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">5. 响应式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E6%80%BB%E7%BB%93"><span class="toc-text">📌 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E4%B8%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">一、语言深度与底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Swift-%E9%AB%98%E9%98%B6%E7%89%B9%E6%80%A7"><span class="toc-text">1. Swift 高阶特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Objective-C-%E5%BA%95%E5%B1%82"><span class="toc-text">2. Objective-C 底层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86"><span class="toc-text">二、系统机制与框架原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-UIKit-%E4%B8%8E%E6%B8%B2%E6%9F%93"><span class="toc-text">1. UIKit 与渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8"><span class="toc-text">2. 网络与安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3. 数据库与持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%A8%A1%E5%BC%8F"><span class="toc-text">三、架构设计与模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B"><span class="toc-text">1. 架构演进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98"><span class="toc-text">2. 设计模式实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-text">四、性能优化与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-text">1. 性能调优</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E8%AF%95%E4%B8%8E%E9%80%86%E5%90%91"><span class="toc-text">2. 调试与逆向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BB%BC%E5%90%88%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF"><span class="toc-text">五、综合场景与前沿技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%8D%E6%9D%82%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">1. 复杂场景设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF"><span class="toc-text">2. 前沿技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%9E%E6%88%98%E7%BC%96%E7%A0%81%E9%A2%98"><span class="toc-text">六、实战编码题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E5%AF%9F%E9%87%8D%E7%82%B9"><span class="toc-text">考察重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">1. 基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Getter-%E5%92%8C-Setter-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2. Getter 和 Setter 的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%88Computed-Property%EF%BC%89"><span class="toc-text">(1) 计算属性（Computed Property）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%EF%BC%88Stored-Property%EF%BC%89"><span class="toc-text">(2) 存储属性（Stored Property）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%82%E5%AF%9F%E5%99%A8%EF%BC%88willSet-%E5%92%8C-didSet%EF%BC%89%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3. 观察器（willSet 和 didSet）的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">调用顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B"><span class="toc-text">示例流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-text">4. 关键区别与作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%AB%98%E7%BA%A7%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">5. 高级场景与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E4%B8%8D%E8%A7%A6%E5%8F%91%E8%A7%82%E5%AF%9F%E5%99%A8"><span class="toc-text">(1) 初始化阶段不触发观察器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E5%9C%A8-didSet-%E4%B8%AD%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91%E4%BF%AE%E6%94%B9"><span class="toc-text">(2) 避免在 didSet 中重复触发修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%A7%82%E5%AF%9F%E5%99%A8%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-text">(3) 计算属性与观察器的互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-text">(4) 性能影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="toc-text">6. 综合示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%B1-%E4%B8%80%E3%80%81Struct-%E4%B8%8E-Class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">🧱 一、Struct 与 Class 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">结构体适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E4%BA%8C%E3%80%81Struct-%E4%B8%8E-Class-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">🔧 二、Struct 与 Class 初始化注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Struct-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">Struct 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">Class 初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AC-%E4%B8%89%E3%80%81Class-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%81%B5%E5%AE%88-Codable-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">🧬 三、Class 是否可以遵守 Codable 协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-Codable-%E5%AD%97%E6%AE%B5%E5%90%8D-%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-text">🧩 四、如何处理 Codable 字段名&#x2F;类型不一致</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-CodingKeys-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E6%AE%B5%E6%98%A0%E5%B0%84"><span class="toc-text">✅ 方法一：使用 CodingKeys 自定义字段映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%8C%E6%89%8B%E5%8A%A8-decode-encode"><span class="toc-text">✅ 方法二：字段类型不一致，手动 decode&#x2F;encode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%93-%E4%BA%94%E3%80%81Optional-%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">❓ 五、Optional 的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A6-%E5%85%AD%E3%80%81Swift-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">🚦 六、Swift 多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89"><span class="toc-text">1. GCD（Grand Central Dispatch）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97-%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-text">异步队列 &amp; 同步队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="toc-text">延迟执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97-%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-text">并发队列 &amp; 串行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DispatchGroup"><span class="toc-text">DispatchGroup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Swift-5-5-async-await%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">2. Swift 5.5+ async&#x2F;await（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-text">并发执行任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TaskGroup-%E4%BD%BF%E7%94%A8"><span class="toc-text">TaskGroup 使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%83%E3%80%81%E8%A1%A5%E5%85%85%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BB%BA%E8%AE%AE"><span class="toc-text">🧠 七、补充高级面试题建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-Swift-%E4%B8%AD-enum-%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">❓ Swift 中 enum 是值类型还是引用类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-Swift-%E4%B8%AD-mutating-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">❓ Swift 中 mutating 关键字作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-Swift-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-retain-cycle%EF%BC%9F"><span class="toc-text">❓ Swift 如何防止 retain cycle？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81Protocol-%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">🧩 一、Protocol 协议相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-Protocol-%E5%92%8C-Class-Struct-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">❓ Protocol 和 Class&#x2F;Struct 有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84-associatedtype-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">❓ 协议中的 associatedtype 有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-Protocol-Extension-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">❓ Protocol Extension 有什么用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AC-%E4%BA%8C%E3%80%81%E6%B3%9B%E5%9E%8B%EF%BC%88Generics%EF%BC%89"><span class="toc-text">🧬 二、泛型（Generics）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">❓ 如何写一个泛型函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E5%86%99%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">❓ 泛型约束写法有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%89%E3%80%81%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="toc-text">🧠 三、闭包（Closure）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E9%97%AD%E5%8C%85%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">❓ 闭包与函数的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E9%97%AD%E5%8C%85%E7%9A%84%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">❓ 闭包的语法简化过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%97%AD%E5%8C%85%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">❓ 如何避免闭包导致的循环引用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9A-%E5%9B%9B%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">📚 四、高阶函数面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-text">常见高阶函数总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E7%A4%BA%E4%BE%8B%E9%A2%98"><span class="toc-text">面试示例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E4%BA%94%E3%80%81Combine-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">🔁 五、Combine 基础面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-Combine-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">❓ Combine 的核心组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Combine-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-text">❓ 示例：使用 Combine 实现双向绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%8A-%E5%85%AD%E3%80%81RxSwift-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">🌊 六、RxSwift 基础面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-RxSwift-%E4%B8%8E-Combine-%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-text">❓ RxSwift 与 Combine 的异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-Observable%EF%BC%9F"><span class="toc-text">❓ 如何创建 Observable？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%97%91%EF%B8%8F-%E4%B8%83%E3%80%81ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">🗑️ 七、ARC 内存管理面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-Swift-%E7%9A%84-ARC-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-text">❓ Swift 的 ARC 如何工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-strong-weak-unowned-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">❓ strong &#x2F; weak &#x2F; unowned 区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%88Retain-Cycle%EF%BC%89%EF%BC%9F"><span class="toc-text">❓ 如何解决循环引用（Retain Cycle）？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-Bonus%EF%BC%9ASwift-%E9%9D%A2%E8%AF%95%E8%AE%BE%E8%AE%A1%E9%A2%98"><span class="toc-text">🧪 Bonus：Swift 面试设计题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">iOS 面试题大全（Objective-C + Swift）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-text">一、语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Objective-C"><span class="toc-text">Objective-C</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift"><span class="toc-text">Swift</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">二、内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text">三、多线程与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD"><span class="toc-text">GCD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OperationQueue"><span class="toc-text">OperationQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-async-await"><span class="toc-text">Swift async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">四、网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">五、数据库与持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">六、设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="toc-text">七、常用框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Combine"><span class="toc-text">Combine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RxSwift"><span class="toc-text">RxSwift</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%AB%98%E9%98%B6-Swift-%E8%AF%AD%E6%B3%95"><span class="toc-text">八、高阶 Swift 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%85%B6%E4%BB%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">九、其他基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81Swift-%E8%BF%9B%E9%98%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">十、Swift 进阶机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-text">十一、性能优化与调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%B5%8B%E8%AF%95%E4%B8%8E-CI-CD"><span class="toc-text">十二、测试与 CI&#x2F;CD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81iOS-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">十三、iOS 安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Getter-%E4%B8%8E-Setter%EF%BC%88%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-text">一、Getter 与 Setter（计算属性）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="toc-text">生命周期：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81willSet-%E4%B8%8E-didSet%EF%BC%88%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%89"><span class="toc-text">二、willSet 与 didSet（存储属性观察者）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">生命周期和执行顺序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-text">特点和规则：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81get-set-%E4%B8%8E-willSet-didSet-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-text">三、get&#x2F;set 与 willSet&#x2F;didSet 的本质区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-text">四、实践建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-2"><span class="toc-text">1. 基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Getter-%E5%92%8C-Setter-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2"><span class="toc-text">2. Getter 和 Setter 的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%88Computed-Property%EF%BC%89-2"><span class="toc-text">(1) 计算属性（Computed Property）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%EF%BC%88Stored-Property%EF%BC%89-2"><span class="toc-text">(2) 存储属性（Stored Property）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%82%E5%AF%9F%E5%99%A8%EF%BC%88willSet-%E5%92%8C-didSet%EF%BC%89%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2"><span class="toc-text">3. 观察器（willSet 和 didSet）的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F-2"><span class="toc-text">调用顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B-2"><span class="toc-text">示例流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8-2"><span class="toc-text">4. 关键区别与作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%AB%98%E7%BA%A7%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-text">5. 高级场景与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E4%B8%8D%E8%A7%A6%E5%8F%91%E8%A7%82%E5%AF%9F%E5%99%A8-2"><span class="toc-text">(1) 初始化阶段不触发观察器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E5%9C%A8-didSet-%E4%B8%AD%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91%E4%BF%AE%E6%94%B9-2"><span class="toc-text">(2) 避免在 didSet 中重复触发修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E8%A7%82%E5%AF%9F%E5%99%A8%E7%9A%84%E4%BA%92%E6%96%A5-2"><span class="toc-text">(3) 计算属性与观察器的互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D-2"><span class="toc-text">(4) 性能影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">6. 综合示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-interview" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">iOS 基础面试题</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2025.06.09</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Niyao</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>以下是一套系统的 Swift 面试题整理，涵盖核心语法、多线程编程、内存管理及主流框架，问题按模块分类并附详细解答：</p>
<hr />
<h3 id="一、Struct-与-Class-深度对比"><strong>一、Struct 与 Class 深度对比</strong></h3>
<h4 id="1-核心区别">1. 核心区别</h4>
<ul>
<li><strong>值类型 vs 引用类型</strong>：<code>struct</code> 是值类型（栈内存），<code>class</code> 是引用类型（堆内存）</li>
<li><strong>继承</strong>：<code>class</code> 支持继承，<code>struct</code> 不支持</li>
<li><strong>内存管理</strong>：<code>class</code> 需要手动处理引用计数（ARC），<code>struct</code> 无需</li>
<li><strong>线程安全</strong>：<code>struct</code> 天然线程安全（值拷贝），<code>class</code> 需自行同步</li>
<li><strong>性能</strong>：<code>struct</code> 在小数据量时更高效（无堆分配和引用计数开销）</li>
</ul>
<h4 id="2-初始化注意事项">2. 初始化注意事项</h4>
<ul>
<li><strong>Struct</strong>：
<ul>
<li>自动生成成员初始化器（除非自定义 <code>init</code>）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">    <span class="comment">// 自动生成 init(x: Int, y: Int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>Class</strong>：
<ul>
<li>必须为所有非可选属性赋初值（通过默认值或 <code>init</code>）</li>
<li>子类必须先初始化自身属性，再调用 <code>super.init</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h3 id="二、Codable-协议实战"><strong>二、Codable 协议实战</strong></h3>
<h4 id="1-Class-支持-Codable">1. Class 支持 Codable</h4>
<ul>
<li><strong>可以</strong>：只要所有存储属性均遵守 <code>Codable</code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-字段兼容技巧">2. 字段兼容技巧</h4>
<ul>
<li><strong>字段名映射</strong>：使用 <code>CodingKeys</code> 枚举<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> title <span class="operator">=</span> <span class="string">&quot;book_title&quot;</span></span><br><span class="line">        <span class="keyword">case</span> price</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>类型兼容</strong>：自定义 <code>init(from:)</code> 处理类型转换<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Product</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="comment">// 兼容接口返回 id 为 Int 或 String</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> intId <span class="operator">=</span> <span class="keyword">try?</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .id) &#123;</span><br><span class="line">            id <span class="operator">=</span> <span class="type">String</span>(intId)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h3 id="三、Optional-本质剖析"><strong>三、Optional 本质剖析</strong></h3>
<ul>
<li><strong>本质</strong>：<code>Optional</code> 是标准库中的泛型枚举<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Optional</span>&lt;<span class="type">Wrapped</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>底层行为</strong>：编译器通过语法糖（<code>?</code> 和 <code>!</code>）简化操作，实际仍走枚举模式匹配</li>
</ul>
<hr />
<h3 id="四、多线程编程"><strong>四、多线程编程</strong></h3>
<h4 id="1-GCD-核心概念">1. GCD 核心概念</h4>
<ul>
<li><strong>队列类型</strong>：
<ul>
<li><strong>Serial</strong>（串行）：<code>DispatchQueue(label: &quot;serial&quot;)</code></li>
<li><strong>Concurrent</strong>（并行）：<code>DispatchQueue(label: &quot;concurrent&quot;, attributes: .concurrent)</code></li>
</ul>
</li>
<li><strong>常见操作</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">    <span class="comment">// 后台任务</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123; <span class="comment">/* 更新UI */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-async-await-Swift-Concurrency">2. async/await (Swift Concurrency)</h4>
<ul>
<li><strong>关键语法</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">fetchData</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>Task 使用</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> someAsyncFunction()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h3 id="五、Swift-核心语法"><strong>五、Swift 核心语法</strong></h3>
<h4 id="1-Protocol-高级用法">1. Protocol 高级用法</h4>
<ul>
<li><strong>关联类型</strong>（Associated Types）：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>协议组合</strong>：<code>func foo(bar: SomeProtocol &amp; AnotherProtocol)</code></li>
</ul>
<h4 id="2-泛型约束">2. 泛型约束</h4>
<ul>
<li><strong>Where 子句</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">process</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Numeric</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(value <span class="operator">+</span> value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-闭包管理">3. 闭包管理</h4>
<ul>
<li><strong>逃逸闭包</strong>：标记为 <code>@escaping</code> 需注意循环引用<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> completion: (() -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setup</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.completion <span class="operator">=</span> completion</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h3 id="六、内存管理（ARC）"><strong>六、内存管理（ARC）</strong></h3>
<h4 id="1-循环引用解决方案">1. 循环引用解决方案</h4>
<ul>
<li><strong>weak</strong>：<code>weak var delegate: SomeDelegate?</code></li>
<li><strong>unowned</strong>：<code>unowned let owner: SomeClass</code>（无主引用，必须确保对象存活）</li>
<li><strong>捕获列表</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> closure: () -&gt; <span class="type">Void</span> <span class="operator">=</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">self</span>.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h3 id="七、响应式编程框架"><strong>七、响应式编程框架</strong></h3>
<h4 id="1-Combine-核心组件">1. Combine 核心组件</h4>
<ul>
<li><strong>Publisher/Subscriber</strong> 模式：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].publisher</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-RxSwift-核心操作符">2. RxSwift 核心操作符</h4>
<ul>
<li><strong>常用链式调用</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .filter &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">1</span> &#125;</span><br><span class="line">    .map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h3 id="高频进阶面试题"><strong>高频进阶面试题</strong></h3>
<ol>
<li>
<p><strong>为什么 Swift 推荐多用 Struct？</strong></p>
<ul>
<li>值类型线程安全、无引用计数开销、适合不可变数据场景</li>
</ul>
</li>
<li>
<p><strong>如何实现一个线程安全的单例？</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">Singleton</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Protocol Extension 如何实现默认实现？</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Drawable</span> &#123; <span class="keyword">func</span> <span class="title function_">draw</span>() &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;Default implementation&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>@MainActor 的作用是什么？</strong></p>
<ul>
<li>确保代码在主线程执行，替代 <code>DispatchQueue.main.async</code></li>
</ul>
</li>
</ol>
<hr />
<p>以下是一份全面覆盖 <strong>Objective-C</strong> 和 <strong>Swift</strong> 的 iOS 基础面试题，涵盖 <strong>内存管理、多线程、设计模式、网络、数据库、框架</strong> 等核心领域，并针对 Swift 语法（如 <code>struct</code>/<code>class</code>、<code>Codable</code>、<code>Optional</code>、多线程、闭包、响应式编程等）进行深入整理。</p>
<hr />
<h2 id="📌-iOS-基础面试题（Objective-C-Swift）"><strong>📌 iOS 基础面试题（Objective-C + Swift）</strong></h2>
<hr />
<h2 id="一、Objective-C-基础"><strong>一、Objective-C 基础</strong></h2>
<h3 id="1-内存管理"><strong>1. 内存管理</strong></h3>
<ol>
<li><strong>什么是 ARC？MRC 和 ARC 的区别？</strong></li>
<li><strong><code>strong</code>、<code>weak</code>、<code>assign</code>、<code>copy</code>、<code>unsafe_unretained</code> 的区别？</strong></li>
<li><strong>循环引用的原因及解决方案（<code>weak</code>、<code>block</code> 弱引用）？</strong></li>
<li><strong><code>autoreleasepool</code> 的作用？使用场景？</strong></li>
<li><strong><code>dealloc</code> 方法的作用？能否调用 <code>[super dealloc]</code>？</strong></li>
</ol>
<h3 id="2-Runtime"><strong>2. Runtime</strong></h3>
<ol start="6">
<li><strong>什么是 Runtime？动态特性有哪些？</strong></li>
<li><strong><code>objc_msgSend</code> 的作用？消息转发流程（<code>resolveInstanceMethod</code>、<code>forwardingTargetForSelector</code>、<code>methodSignatureForSelector</code>）？</strong></li>
<li><strong><code>class</code> 和 <code>meta-class</code> 的区别？<code>isKindOfClass</code> 和 <code>isMemberOfClass</code> 的区别？</strong></li>
<li><strong><code>method swizzling</code> 是什么？如何实现？有哪些坑？</strong></li>
<li><strong>KVO 的实现原理？如何手动触发 KVO？</strong></li>
</ol>
<h3 id="3-多线程"><strong>3. 多线程</strong></h3>
<ol start="11">
<li><strong>GCD 的队列类型（<code>serial</code>、<code>concurrent</code>、<code>main</code>、<code>global</code>）？</strong></li>
<li><strong><code>dispatch_barrier_async</code> 的作用？</strong></li>
<li><strong>NSOperation 和 GCD 的区别？<code>NSOperationQueue</code> 如何控制并发数？</strong></li>
<li><strong><code>@synchronized</code> 的原理？它和 <code>NSLock</code>、<code>dispatch_semaphore</code> 的区别？</strong></li>
<li><strong>多线程常见问题（死锁、线程安全、优先级反转）？</strong></li>
</ol>
<h3 id="4-设计模式"><strong>4. 设计模式</strong></h3>
<ol start="16">
<li><strong>MVC、MVP、MVVM 的区别？iOS 中 MVC 的问题？</strong></li>
<li><strong>单例模式的实现（线程安全）？</strong></li>
<li><strong>Delegate 和 Notification 的区别？</strong></li>
<li><strong>工厂模式、观察者模式、责任链模式的应用场景？</strong></li>
<li><strong>KVC 和 KVO 的使用场景？</strong></li>
</ol>
<hr />
<h2 id="二、Swift-基础"><strong>二、Swift 基础</strong></h2>
<h3 id="1-struct-vs-class"><strong>1. <code>struct</code> vs <code>class</code></strong></h3>
<ol start="21">
<li><strong><code>struct</code> 和 <code>class</code> 的核心区别（值类型 vs 引用类型、内存管理、继承等）？</strong></li>
<li><strong><code>struct</code> 自动生成 <code>init</code>，<code>class</code> 必须手动初始化？</strong></li>
<li><strong><code>mutating</code> 关键字的作用？</strong></li>
<li><strong><code>final</code> 关键字的作用？</strong></li>
</ol>
<h3 id="2-Optional"><strong>2. <code>Optional</code></strong></h3>
<ol start="25">
<li><strong><code>Optional</code> 的本质是什么？（<code>enum</code>：<code>.none</code> 和 <code>.some(Wrapped)</code>）</strong></li>
<li><strong><code>??</code>、<code>if let</code>、<code>guard let</code>、<code>optional chaining</code> 的区别？</strong></li>
<li><strong><code>@unwrapped</code> 和隐式解包（<code>String!</code>）的区别？</strong></li>
</ol>
<h3 id="3-协议-泛型"><strong>3. 协议 &amp; 泛型</strong></h3>
<ol start="28">
<li><strong><code>Protocol</code> 的 <code>associatedtype</code> 是什么？如何约束？</strong></li>
<li><strong><code>where</code> 子句在泛型中的作用？</strong></li>
<li><strong><code>Self</code> 和 <code>self</code> 的区别？</strong></li>
</ol>
<h3 id="4-闭包"><strong>4. 闭包</strong></h3>
<ol start="31">
<li><strong>逃逸闭包（<code>@escaping</code>）和非逃逸闭包的区别？</strong></li>
<li><strong><code>[weak self]</code> 和 <code>[unowned self]</code> 的区别？</strong></li>
<li><strong><code>lazy var</code> + 闭包初始化？</strong></li>
</ol>
<h3 id="5-多线程（Swift）"><strong>5. 多线程（Swift）</strong></h3>
<ol start="34">
<li><strong>GCD 在 Swift 中的使用（<code>DispatchQueue</code>、<code>DispatchGroup</code>）？</strong></li>
<li><strong><code>async/await</code> 和 <code>Task</code> 的使用？</strong></li>
<li><strong><code>@MainActor</code> 的作用？</strong></li>
</ol>
<h3 id="6-Codable"><strong>6. <code>Codable</code></strong></h3>
<ol start="37">
<li><strong><code>class</code> 可以遵守 <code>Codable</code> 吗？如何实现？</strong></li>
<li><strong>如何用 <code>CodingKeys</code> 映射 JSON 字段？</strong></li>
<li><strong>如何处理接口返回的 <code>Int</code>/<code>String</code> 兼容问题？</strong></li>
</ol>
<h3 id="7-内存管理（Swift）"><strong>7. 内存管理（Swift）</strong></h3>
<ol start="40">
<li><strong><code>weak</code>、<code>unowned</code>、<code>strong</code> 的区别？</strong></li>
<li><strong>循环引用在 Swift 中的常见场景及解决方案？</strong></li>
<li><strong><code>deinit</code> 的作用？</strong></li>
</ol>
<h3 id="8-响应式编程"><strong>8. 响应式编程</strong></h3>
<ol start="43">
<li><strong>Combine 的核心组件（<code>Publisher</code>、<code>Subscriber</code>、<code>Subject</code>）？</strong></li>
<li><strong>RxSwift 的常见操作符（<code>map</code>、<code>filter</code>、<code>flatMap</code>）？</strong></li>
<li><strong><code>Observable</code> 和 <code>Future</code> 的区别？</strong></li>
</ol>
<hr />
<h2 id="三、iOS-开发基础"><strong>三、iOS 开发基础</strong></h2>
<h3 id="1-UI-动画"><strong>1. UI &amp; 动画</strong></h3>
<ol start="46">
<li><strong><code>UIView</code> 和 <code>CALayer</code> 的区别？</strong></li>
<li><strong><code>frame</code>、<code>bounds</code>、<code>center</code> 的区别？</strong></li>
<li><strong>Auto Layout 的原理？<code>intrinsicContentSize</code> 的作用？</strong></li>
<li><strong><code>UIView.animate</code> 和 <code>Core Animation</code> 的区别？</strong></li>
<li><strong>离屏渲染（<code>cornerRadius</code>、<code>shadow</code>）的优化？</strong></li>
</ol>
<h3 id="2-网络"><strong>2. 网络</strong></h3>
<ol start="51">
<li><strong>HTTP 和 HTTPS 的区别？HTTPS 的握手过程？</strong></li>
<li><strong><code>URLSession</code> 的使用（<code>dataTask</code>、<code>uploadTask</code>、<code>downloadTask</code>）？</strong></li>
<li><strong><code>Alamofire</code> 的核心实现？</strong></li>
<li><strong><code>Cookie</code> 和 <code>Session</code> 的区别？</strong></li>
</ol>
<h3 id="3-数据库"><strong>3. 数据库</strong></h3>
<ol start="55">
<li><strong><code>Core Data</code> 和 <code>Realm</code> 的区别？</strong></li>
<li><strong>SQLite 的增删改查（<code>FMDB</code> 的使用）？</strong></li>
<li><strong><code>@FetchRequest</code> 在 SwiftUI 中的作用？</strong></li>
</ol>
<h3 id="4-性能优化"><strong>4. 性能优化</strong></h3>
<ol start="58">
<li><strong>卡顿检测（<code>CADisplayLink</code>、<code>Instruments</code>）？</strong></li>
<li><strong>内存泄漏检测（<code>Leaks</code>、<code>MLeaksFinder</code>）？</strong></li>
<li><strong>图片加载优化（<code>SDWebImage</code> 的缓存策略）？</strong></li>
</ol>
<h3 id="5-架构-设计模式"><strong>5. 架构 &amp; 设计模式</strong></h3>
<ol start="61">
<li><strong>如何设计一个网络层？</strong></li>
<li><strong>如何实现一个路由（URL Router）？</strong></li>
<li><strong>依赖注入（DI）的实现方式？</strong></li>
</ol>
<hr />
<h2 id="📌-高频-Swift-面试题"><strong>📌 高频 Swift 面试题</strong></h2>
<h3 id="1-struct-vs-class-2"><strong>1. <code>struct</code> vs <code>class</code></strong></h3>
<ul>
<li><strong>值类型 vs 引用类型</strong></li>
<li><strong>内存分配（栈 vs 堆）</strong></li>
<li><strong>线程安全性</strong></li>
<li><strong><code>mutating</code> 关键字的作用</strong></li>
</ul>
<h3 id="2-Codable"><strong>2. <code>Codable</code></strong></h3>
<ul>
<li><strong><code>class</code> 如何遵守 <code>Codable</code>？</strong></li>
<li><strong><code>CodingKeys</code> 的使用</strong></li>
<li><strong>处理接口字段不一致（<code>Int</code>/<code>String</code> 兼容）</strong></li>
</ul>
<h3 id="3-多线程-2"><strong>3. 多线程</strong></h3>
<ul>
<li><strong>GCD（<code>DispatchQueue</code>、<code>DispatchGroup</code>）</strong></li>
<li><strong><code>async/await</code> 的使用</strong></li>
<li><strong><code>@MainActor</code> 的作用</strong></li>
</ul>
<h3 id="4-内存管理"><strong>4. 内存管理</strong></h3>
<ul>
<li><strong><code>weak</code> vs <code>unowned</code></strong></li>
<li><strong>循环引用的解决方案</strong></li>
</ul>
<h3 id="5-响应式编程"><strong>5. 响应式编程</strong></h3>
<ul>
<li><strong>Combine 的核心概念</strong></li>
<li><strong>RxSwift 的常见操作符</strong></li>
</ul>
<hr />
<h2 id="📌-总结"><strong>📌 总结</strong></h2>
<ul>
<li><strong>Objective-C</strong>：重点在 <strong>内存管理（ARC）、Runtime、多线程（GCD）、设计模式（Delegate、KVO）</strong></li>
<li><strong>Swift</strong>：重点在 <strong><code>struct</code>/<code>class</code>、<code>Optional</code>、<code>Codable</code>、多线程（<code>async/await</code>）、内存管理</strong></li>
<li><strong>iOS 基础</strong>：<strong>UI（Auto Layout）、网络（<code>URLSession</code>）、数据库（<code>Core Data</code>）、性能优化</strong></li>
</ul>
<p>以下是为资深 iOS 开发工程师设计的高阶综合面试题，涵盖底层原理、架构设计、性能优化及前沿技术，分为 <strong>语言深度</strong>、<strong>系统机制</strong>、<strong>架构设计</strong>、<strong>性能优化</strong> 和 <strong>综合场景</strong> 五大模块：</p>
<hr />
<h3 id="一、语言深度与底层原理"><strong>一、语言深度与底层原理</strong></h3>
<h4 id="1-Swift-高阶特性"><strong>1. Swift 高阶特性</strong></h4>
<ol>
<li>
<p><strong>泛型与协议</strong></p>
<ul>
<li>如何设计一个支持泛型缓存的 <code>Repository</code> 模式？</li>
<li><code>associatedtype</code> 与 <code>some</code>、<code>any</code> 关键字的区别？Swift 5.7 的不透明类型优化了什么？</li>
<li>为什么 <code>Protocol</code> 不能直接作为类型使用？如何用类型擦除（Type Erasure）解决？</li>
</ul>
</li>
<li>
<p><strong>内存管理</strong></p>
<ul>
<li>Swift 的 <code>unowned</code> 和 <code>weak</code> 在底层是如何实现的？何时会导致野指针？</li>
<li><code>withUnsafeBytes</code> 和 <code>withMemoryRebound</code> 的使用场景？如何安全操作指针？</li>
</ul>
</li>
<li>
<p><strong>并发模型</strong></p>
<ul>
<li><code>actor</code> 的隔离机制如何实现？与 <code>@MainActor</code> 的线程调度差异？</li>
<li><code>Sendable</code> 协议的作用？如何让自定义类型支持跨线程传递？</li>
</ul>
</li>
</ol>
<h4 id="2-Objective-C-底层"><strong>2. Objective-C 底层</strong></h4>
<ol start="4">
<li>
<p><strong>Runtime 进阶</strong></p>
<ul>
<li><code>objc_msgSend</code> 的快速查找（缓存）和慢速查找（方法列表）流程？</li>
<li>如何通过 <code>NSInvocation</code> 动态调用任意参数的方法？</li>
<li><code>class_ro_t</code> 和 <code>class_rw_t</code> 的区别？方法列表的动态扩展如何实现？</li>
</ul>
</li>
<li>
<p><strong>内存管理</strong></p>
<ul>
<li><code>NSCache</code> 和 <code>NSDictionary</code> 的内存策略差异？如何实现 LRU 缓存？</li>
<li><code>__weak</code> 变量的底层实现（SideTable 结构）？</li>
</ul>
</li>
</ol>
<hr />
<h3 id="二、系统机制与框架原理"><strong>二、系统机制与框架原理</strong></h3>
<h4 id="1-UIKit-与渲染"><strong>1. UIKit 与渲染</strong></h4>
<ol start="6">
<li>
<p><strong>渲染流水线</strong></p>
<ul>
<li>Core Animation 的 <code>CALayer</code> 提交到 GPU 的完整流程？</li>
<li>离屏渲染（Offscreen Rendering）的底层触发条件及优化方案？</li>
</ul>
</li>
<li>
<p><strong>事件传递</strong></p>
<ul>
<li><code>hitTest:withEvent:</code> 和 <code>pointInside:withEvent:</code> 的调用链路？如何实现穿透点击？</li>
</ul>
</li>
</ol>
<h4 id="2-网络与安全"><strong>2. 网络与安全</strong></h4>
<ol start="8">
<li>
<p><strong>HTTP/2 与 QUIC</strong></p>
<ul>
<li>HTTP/2 的多路复用如何提升性能？与 QUIC 协议的差异？</li>
<li>iOS 如何实现 TLS 1.3 的 0-RTT 加速？</li>
</ul>
</li>
<li>
<p><strong>长连接优化</strong></p>
<ul>
<li>如何设计一个支持断线重连、心跳保活的 WebSocket 客户端？</li>
</ul>
</li>
</ol>
<h4 id="3-数据库与持久化"><strong>3. 数据库与持久化</strong></h4>
<ol start="10">
<li>
<p><strong>Core Data 进阶</strong></p>
<ul>
<li>如何优化 <code>NSFetchedResultsController</code> 在大数据量下的性能？</li>
<li>多线程环境下 <code>NSManagedObjectContext</code> 的合并策略（<code>MergePolicy</code>）？</li>
</ul>
</li>
<li>
<p><strong>SQLite 优化</strong></p>
<ul>
<li>WAL（Write-Ahead Logging）模式的工作原理？如何避免 <code>SQLITE_BUSY</code> 错误？</li>
</ul>
</li>
</ol>
<hr />
<h3 id="三、架构设计与模式"><strong>三、架构设计与模式</strong></h3>
<h4 id="1-架构演进"><strong>1. 架构演进</strong></h4>
<ol start="12">
<li>
<p><strong>从 MVC 到 MVVM</strong></p>
<ul>
<li>如何在不引入 Reactive 框架的情况下实现 MVVM 的数据绑定？</li>
<li><code>ViewModel</code> 如何避免持有 <code>View</code> 导致的循环引用？</li>
</ul>
</li>
<li>
<p><strong>模块化与组件化</strong></p>
<ul>
<li>如何设计一个支持动态插拔的模块化架构（如路由 + Protocol）？</li>
<li><code>CocoaPods</code> 与 <code>Swift Package Manager</code> 的二进制化方案？</li>
</ul>
</li>
</ol>
<h4 id="2-设计模式实战"><strong>2. 设计模式实战</strong></h4>
<ol start="14">
<li>
<p><strong>响应式编程</strong></p>
<ul>
<li>Combine 的 <code>Publisher</code> 冷热信号差异？如何实现自定义 <code>Publisher</code>？</li>
<li>RxSwift 的 <code>flatMap</code> 与 <code>flatMapLatest</code> 在搜索场景中的应用？</li>
</ul>
</li>
<li>
<p><strong>依赖注入</strong></p>
<ul>
<li>如何利用 <code>Property Wrapper</code> 实现类型安全的 DI 容器？</li>
</ul>
</li>
</ol>
<hr />
<h3 id="四、性能优化与调试"><strong>四、性能优化与调试</strong></h3>
<h4 id="1-性能调优"><strong>1. 性能调优</strong></h4>
<ol start="16">
<li>
<p><strong>启动优化</strong></p>
<ul>
<li><code>dyld</code> 动态链接的耗时如何测量？如何减少 <code>__DATA</code> 段的修复时间？</li>
<li><code>+load</code> 和 <code>+initialize</code> 的优化策略？</li>
</ul>
</li>
<li>
<p><strong>内存优化</strong></p>
<ul>
<li>如何通过 <code>VM Tracker</code> 分析内存碎片问题？</li>
<li><code>NSCache</code> 的 <code>totalCostLimit</code> 策略与内存警告的关系？</li>
</ul>
</li>
</ol>
<h4 id="2-调试与逆向"><strong>2. 调试与逆向</strong></h4>
<ol start="18">
<li>
<p><strong>LLDB 高阶</strong></p>
<ul>
<li>如何通过 <code>image lookup -a</code> 定位野指针崩溃？</li>
<li>动态修改 <code>UIView</code> 属性的 LLDB 命令？</li>
</ul>
</li>
<li>
<p><strong>逆向分析</strong></p>
<ul>
<li>如何通过 <code>Hopper</code> 静态分析第三方库的私有 API 调用？</li>
</ul>
</li>
</ol>
<hr />
<h3 id="五、综合场景与前沿技术"><strong>五、综合场景与前沿技术</strong></h3>
<h4 id="1-复杂场景设计"><strong>1. 复杂场景设计</strong></h4>
<ol start="20">
<li>
<p><strong>跨平台方案</strong></p>
<ul>
<li>SwiftUI 与 Flutter 的渲染引擎差异？如何实现高性能的跨平台列表？</li>
</ul>
</li>
<li>
<p><strong>大文件传输</strong></p>
<ul>
<li>如何设计一个支持断点续传、分块校验的文件上传服务？</li>
</ul>
</li>
</ol>
<h4 id="2-前沿技术"><strong>2. 前沿技术</strong></h4>
<ol start="22">
<li>
<p><strong>机器学习</strong></p>
<ul>
<li>Core ML 的模型加密与动态更新方案？</li>
</ul>
</li>
<li>
<p><strong>AR 与 Metal</strong></p>
<ul>
<li>如何通过 <code>Metal</code> 实现自定义的 AR 渲染管线？</li>
</ul>
</li>
</ol>
<hr />
<h3 id="六、实战编码题"><strong>六、实战编码题</strong></h3>
<ol>
<li>
<p><strong>实现线程安全的 LRU 缓存</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;<span class="type">Key</span>: <span class="type">Hashable</span>, <span class="type">Value</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock <span class="operator">=</span> <span class="type">NSLock</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> capacity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cache: [<span class="type">Key</span>: <span class="type">Value</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> order: [<span class="type">Key</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">capacity</span>: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.capacity <span class="operator">=</span> capacity &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="keyword">_</span> <span class="params">key</span>: <span class="type">Key</span>) -&gt; <span class="type">Value</span>? &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value <span class="operator">=</span> cache[key] <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        order.removeAll &#123; <span class="variable">$0</span> <span class="operator">==</span> key &#125;</span><br><span class="line">        order.append(key)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">set</span>(<span class="keyword">_</span> <span class="params">key</span>: <span class="type">Key</span>, <span class="params">value</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        <span class="keyword">if</span> cache[key] <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> cache.count <span class="operator">&gt;=</span> capacity &#123;</span><br><span class="line">            <span class="keyword">let</span> removedKey <span class="operator">=</span> order.removeFirst()</span><br><span class="line">            cache[removedKey] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        cache[key] <span class="operator">=</span> value</span><br><span class="line">        order.append(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>基于 Combine 实现防抖搜索</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SearchViewModel</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> query: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cancellables <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="variable">$query</span></span><br><span class="line">            .debounce(for: .milliseconds(<span class="number">300</span>), scheduler: <span class="type">RunLoop</span>.main)</span><br><span class="line">            .removeDuplicates()</span><br><span class="line">            .sink &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] query <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.performSearch(query: query)</span><br><span class="line">            &#125;</span><br><span class="line">            .store(in: <span class="operator">&amp;</span>cancellables)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">performSearch</span>(<span class="params">query</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Searching for: <span class="subst">\(query)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr />
<h3 id="考察重点"><strong>考察重点</strong></h3>
<ul>
<li><strong>深度</strong>：是否理解语言特性背后的底层机制（如 Swift 的 <code>Optional</code> 枚举、OC 的消息转发）。</li>
<li><strong>架构能力</strong>：能否设计高扩展、低耦合的模块化方案。</li>
<li><strong>性能敏感度</strong>：对渲染管线、内存管理等系统级优化的实践经验。</li>
<li><strong>技术前瞻性</strong>：对 Combine、Swift Concurrency 等新技术的落地思考。</li>
</ul>
<p>在 Swift 中，属性的 <strong>getter</strong>、<strong>setter</strong> 及其观察器（<code>willSet</code>、<code>didSet</code>）的生命周期和调用顺序是属性管理的核心机制。以下是它们的详细解析：</p>
<hr />
<h3 id="1-基本结构"><strong>1. 基本结构</strong></h3>
<p>Swift 中的属性可以分为：</p>
<ul>
<li><strong>存储属性（Stored Property）</strong>：直接存储值，可附加观察器。</li>
<li><strong>计算属性（Computed Property）</strong>：通过 getter/setter 动态计算值，不可附加观察器。</li>
</ul>
<h4 id="示例代码"><strong>示例代码</strong></h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 存储属性 + 观察器</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;willSet: <span class="subst">\(name)</span> → <span class="subst">\(newValue)</span>&quot;</span>) &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;didSet: <span class="subst">\(oldValue)</span> → <span class="subst">\(name)</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">var</span> uppercaseName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name.uppercased() &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; name <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-Getter-和-Setter-的生命周期"><strong>2. Getter 和 Setter 的生命周期</strong></h3>
<h4 id="1-计算属性（Computed-Property）"><strong>(1) 计算属性（Computed Property）</strong></h4>
<ul>
<li><strong>Getter</strong>：每次访问属性时调用。</li>
<li><strong>Setter</strong>：每次赋值时调用（必须有 <code>set</code> 才能修改值）。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(person.uppercaseName) <span class="comment">// 调用 getter</span></span><br><span class="line">person.uppercaseName <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span> <span class="comment">// 调用 setter → 触发 name 的观察器</span></span><br></pre></td></tr></table></figure>
<h4 id="2-存储属性（Stored-Property）"><strong>(2) 存储属性（Stored Property）</strong></h4>
<ul>
<li><strong>默认行为</strong>：直接读写存储的值。</li>
<li><strong>附加观察器</strong>：通过 <code>willSet</code> 和 <code>didSet</code> 监听变化。</li>
</ul>
<hr />
<h3 id="3-观察器（willSet-和-didSet）的生命周期"><strong>3. 观察器（<code>willSet</code> 和 <code>didSet</code>）的生命周期</strong></h3>
<h4 id="调用顺序"><strong>调用顺序</strong></h4>
<p>当属性值被修改时，触发顺序如下：</p>
<ol>
<li><strong>原始值</strong>：保存当前值（用于 <code>didSet</code> 的 <code>oldValue</code>）。</li>
<li><strong><code>willSet</code></strong>：新值即将写入（可访问 <code>newValue</code>）。</li>
<li><strong>赋值操作</strong>：实际修改存储的值。</li>
<li><strong><code>didSet</code></strong>：新值已写入（可访问 <code>oldValue</code>）。</li>
</ol>
<h4 id="示例流程"><strong>示例流程</strong></h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// willSet: Alice → Bob</span></span><br><span class="line"><span class="comment">// didSet: Alice → Bob</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="4-关键区别与作用"><strong>4. 关键区别与作用</strong></h3>
<table>
<thead>
<tr>
<th>机制</th>
<th>触发时机</th>
<th>可访问的值</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Getter</strong></td>
<td>每次读取属性时</td>
<td>返回计算值</td>
<td>动态计算属性值（如格式化数据）。</td>
</tr>
<tr>
<td><strong>Setter</strong></td>
<td>每次赋值时（计算属性）</td>
<td><code>newValue</code></td>
<td>验证或处理新值（如过滤非法输入）。</td>
</tr>
<tr>
<td><strong><code>willSet</code></strong></td>
<td>值被写入前</td>
<td><code>newValue</code></td>
<td>执行前置操作（如日志记录、触发 UI 更新）。</td>
</tr>
<tr>
<td><strong><code>didSet</code></strong></td>
<td>值被写入后</td>
<td><code>oldValue</code></td>
<td>执行后置操作（如数据同步、发送通知）。</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="5-高级场景与注意事项"><strong>5. 高级场景与注意事项</strong></h3>
<h4 id="1-初始化阶段不触发观察器"><strong>(1) 初始化阶段不触发观察器</strong></h4>
<ul>
<li><strong>观察器仅在初始化完成后生效</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name <span class="comment">// 不会触发 willSet/didSet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-避免在-didSet-中重复触发修改"><strong>(2) 避免在 <code>didSet</code> 中重复触发修改</strong></h4>
<ul>
<li><strong>死循环风险</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        score <span class="operator">=</span> <span class="built_in">min</span>(score, <span class="number">100</span>) <span class="comment">// 会再次触发 didSet！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>解决方案</strong>：通过临时变量或条件判断避免循环。</li>
</ul>
<h4 id="3-计算属性与观察器的互斥"><strong>(3) 计算属性与观察器的互斥</strong></h4>
<ul>
<li><strong>计算属性不能附加观察器</strong>（因为它的值由 getter/setter 动态决定）。</li>
</ul>
<h4 id="4-性能影响"><strong>(4) 性能影响</strong></h4>
<ul>
<li><strong>观察器会增加调用开销</strong>：高频修改的属性需谨慎使用。</li>
</ul>
<hr />
<h3 id="6-综合示例"><strong>6. 综合示例</strong></h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Temperature</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> celsius: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;摄氏温度即将从 <span class="subst">\(celsius)</span> 变为 <span class="subst">\(newValue)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> celsius <span class="operator">&gt;</span> <span class="number">100</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;警告：温度超过 100°C&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fahrenheit: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> celsius <span class="operator">*</span> <span class="number">1.8</span> <span class="operator">+</span> <span class="number">32</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; celsius <span class="operator">=</span> (newValue <span class="operator">-</span> <span class="number">32</span>) <span class="operator">/</span> <span class="number">1.8</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp <span class="operator">=</span> <span class="type">Temperature</span>()</span><br><span class="line">temp.fahrenheit <span class="operator">=</span> <span class="number">212</span> <span class="comment">// 触发 celsius 的观察器</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// willSet: 0.0 → 100.0</span></span><br><span class="line"><span class="comment">// 警告：温度超过 100°C</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结"><strong>总结</strong></h3>
<ul>
<li>
<p><strong>Getter/Setter</strong>：控制属性的读写行为（计算属性专属）。</p>
</li>
<li>
<p><strong><code>willSet</code>/<code>didSet</code></strong>：监听存储属性的变化（初始化时不触发）。</p>
</li>
<li>
<p><strong>设计原则</strong>：</p>
<ul>
<li>用计算属性封装派生数据。</li>
<li>用观察器处理副作用（如持久化、UI 更新）。</li>
<li></li>
</ul>
<p>以下是一套详尽的 Swift 面试题与解析，涵盖你提到的关键点，包括结构体与类的差异、初始化、<code>Codable</code> 协议、<code>Optional</code> 本质、以及多线程编程（GCD 与 <code>async/await</code>）等内容。</p>
</li>
</ul>
<hr />
<h2 id="🧱-一、Struct-与-Class-的区别">🧱 一、Struct 与 Class 的区别</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Struct</th>
<th>Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>值类型（Value Type）</td>
<td>引用类型（Reference Type）</td>
</tr>
<tr>
<td>存储方式</td>
<td>每次赋值都会复制一份</td>
<td>多个引用指向同一实例</td>
</tr>
<tr>
<td>继承</td>
<td>不支持继承</td>
<td>支持继承</td>
</tr>
<tr>
<td>ARC 管理</td>
<td>不使用 ARC</td>
<td>使用 ARC</td>
</tr>
<tr>
<td>可变性</td>
<td><code>let</code> 定义不可变</td>
<td><code>let</code> 定义的类实例，其属性可变</td>
</tr>
<tr>
<td>可用于哪些场景</td>
<td>更适合轻量模型、不可变数据</td>
<td>更适合有生命周期管理、共享状态的对象</td>
</tr>
</tbody>
</table>
<h3 id="结构体适用场景">结构体适用场景</h3>
<ul>
<li>数据模型（如坐标、尺寸）</li>
<li>SwiftUI View</li>
<li>Codable 轻量数据解析</li>
</ul>
<hr />
<h2 id="🔧-二、Struct-与-Class-初始化注意事项">🔧 二、Struct 与 Class 初始化注意事项</h2>
<h3 id="Struct-初始化">Struct 初始化</h3>
<ul>
<li>自动生成 <code>memberwise initializer</code>（逐一成员初始化器）</li>
<li>如果你自定义了 <code>init()</code>，系统不再自动生成默认的成员初始化器</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Tom&quot;</span>, age: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Class-初始化">Class 初始化</h3>
<ul>
<li>必须保证所有非可选属性在 <code>init</code> 中初始化</li>
<li>可以定义 <code>convenience</code> 初始化器调用 <code>designated</code> 初始化器</li>
<li>支持继承链中的初始化顺序</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">breed</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.breed <span class="operator">=</span> breed</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="🧬-三、Class-是否可以遵守-Codable-协议？">🧬 三、Class 是否可以遵守 Codable 协议？</h2>
<p>✅ 可以。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>如果包含自定义 init 或继承结构体，需手动实现 <code>encode(to:)</code> 和 <code>init(from:)</code></li>
<li>遇到嵌套 class 时，使用 JSONDecoder 会递归解码</li>
</ul>
<hr />
<h2 id="🧩-四、如何处理-Codable-字段名-类型不一致">🧩 四、如何处理 Codable 字段名/类型不一致</h2>
<h3 id="✅-方法一：使用-CodingKeys-自定义字段映射">✅ 方法一：使用 <code>CodingKeys</code> 自定义字段映射</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name <span class="operator">=</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">        <span class="keyword">case</span> age <span class="operator">=</span> <span class="string">&quot;user_age&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-方法二：字段类型不一致，手动-decode-encode">✅ 方法二：字段类型不一致，手动 decode/encode</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> ageString <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .age)</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> <span class="type">Int</span>(ageString) <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="❓-五、Optional-的本质是什么？">❓ 五、Optional 的本质是什么？</h2>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Optional</span>&lt;<span class="type">Wrapped</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Optional</code> 是一个泛型 <code>enum</code>，有两个 case</li>
<li><code>nil</code> 实际上就是 <code>.none</code></li>
<li>常用 <code>if let</code> / <code>guard let</code> / <code>??</code> 等语法糖简化解包过程</li>
</ul>
<hr />
<h2 id="🚦-六、Swift-多线程编程">🚦 六、Swift 多线程编程</h2>
<h3 id="1-GCD（Grand-Central-Dispatch）">1. GCD（Grand Central Dispatch）</h3>
<h4 id="异步队列-同步队列">异步队列 &amp; 同步队列</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="comment">// 后台线程</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// 回主线程更新 UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="延迟执行">延迟执行</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">2.0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 秒后执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并发队列-串行队列">并发队列 &amp; 串行队列</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;serial&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> concurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;concurrent&quot;</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure>
<h4 id="DispatchGroup">DispatchGroup</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">fetchData1 &#123; group.leave() &#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">fetchData2 &#123; group.leave() &#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;全部完成&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-Swift-5-5-async-await（推荐）">2. Swift 5.5+ async/await（推荐）</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">fetchData</span>() <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;数据&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> fetchData()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并发执行任务">并发执行任务</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">let</span> a <span class="operator">=</span> loadA()</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">let</span> b <span class="operator">=</span> loadB()</span><br><span class="line"><span class="keyword">let</span> (resultA, resultB) <span class="operator">=</span> <span class="keyword">await</span> (a, b)</span><br></pre></td></tr></table></figure>
<h4 id="TaskGroup-使用">TaskGroup 使用</h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> withTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">3</span> &#123;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">return</span> i <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> result <span class="keyword">in</span> group &#123;</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="🧠-七、补充高级面试题建议">🧠 七、补充高级面试题建议</h2>
<h3 id="❓-Swift-中-enum-是值类型还是引用类型？">❓ Swift 中 enum 是值类型还是引用类型？</h3>
<ul>
<li>值类型</li>
<li>可以携带关联值</li>
<li>可以实现协议、支持模式匹配（<code>switch</code>）</li>
</ul>
<h3 id="❓-Swift-中-mutating-关键字作用？">❓ Swift 中 mutating 关键字作用？</h3>
<ul>
<li>允许在 <code>struct</code> 或 <code>enum</code> 的方法中修改 <code>self</code> 或属性值</li>
</ul>
<h3 id="❓-Swift-如何防止-retain-cycle？">❓ Swift 如何防止 retain cycle？</h3>
<ul>
<li>使用 <code>weak</code> / <code>unowned</code> 引用</li>
<li>注意闭包捕获列表：<code>[weak self]</code> / <code>[unowned self]</code></li>
</ul>
<hr />
<p>以下是对 Swift 更高阶语法领域的详尽面试题扩展，涵盖 <code>Protocol</code>、泛型、闭包、高阶函数、Combine、RxSwift 及 ARC 内存管理。</p>
<hr />
<h2 id="🧩-一、Protocol-协议相关面试题">🧩 一、Protocol 协议相关面试题</h2>
<h3 id="❓-Protocol-和-Class-Struct-有什么不同？">❓ Protocol 和 Class/Struct 有什么不同？</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Protocol</th>
<th>Class/Struct</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的</td>
<td>描述行为规范</td>
<td>数据结构定义</td>
</tr>
<tr>
<td>是否可继承</td>
<td>支持多继承</td>
<td>Class 仅支持单继承</td>
</tr>
<tr>
<td>是否可实例化</td>
<td>❌ 不可</td>
<td>✅ 可以</td>
</tr>
<tr>
<td>可否添加默认实现</td>
<td>✅ 通过 extension</td>
<td>✅ 直接实现</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="❓-协议中的-associatedtype-有什么作用？">❓ 协议中的 <code>associatedtype</code> 有什么作用？</h3>
<ul>
<li>定义占位符类型，用于泛型协议</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">item</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不能直接在 <code>let x: DataSource</code> 中使用，需使用泛型约束 <code>some DataSource</code></li>
</ul>
<hr />
<h3 id="❓-Protocol-Extension-有什么用？">❓ Protocol Extension 有什么用？</h3>
<ul>
<li>为协议统一添加默认实现</li>
<li>允许扩展功能而不破坏已有 conformer 的代码</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="🧬-二、泛型（Generics）">🧬 二、泛型（Generics）</h2>
<h3 id="❓-如何写一个泛型函数？">❓ 如何写一个泛型函数？</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwo</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="❓-泛型约束写法有哪些？">❓ 泛型约束写法有哪些？</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printDescription</span>&lt;<span class="type">T</span>: <span class="type">CustomStringConvertible</span>&gt;(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value.description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多协议约束：<code>T: A &amp; B</code></li>
<li>where 语句：<code>where T.Element == String</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">allStrings</span>&lt;<span class="type">T</span>: <span class="type">Sequence</span>&gt;(<span class="params">input</span>: <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> str <span class="keyword">in</span> input &#123; <span class="built_in">print</span>(str) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="🧠-三、闭包（Closure）">🧠 三、闭包（Closure）</h2>
<h3 id="❓-闭包与函数的区别？">❓ 闭包与函数的区别？</h3>
<ul>
<li>闭包是“可捕获上下文”的代码块</li>
<li>函数是命名的、不能捕获上下文</li>
</ul>
<h3 id="❓-闭包的语法简化过程？">❓ 闭包的语法简化过程？</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始</span></span><br><span class="line"><span class="keyword">let</span> add <span class="operator">=</span> &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="keyword">return</span> a <span class="operator">+</span> b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略类型</span></span><br><span class="line"><span class="keyword">let</span> add <span class="operator">=</span> &#123; a, b <span class="keyword">in</span> a <span class="operator">+</span> b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾随闭包</span></span><br><span class="line">someFunction &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="❓-如何避免闭包导致的循环引用？">❓ 如何避免闭包导致的循环引用？</h3>
<ul>
<li>使用 <code>[weak self]</code> 或 <code>[unowned self]</code> 捕获列表</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">loadData &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span><span class="operator">?</span>.updateUI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="📚-四、高阶函数面试题">📚 四、高阶函数面试题</h2>
<h3 id="常见高阶函数总结">常见高阶函数总结</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>map</code></td>
<td>转换每个元素</td>
</tr>
<tr>
<td><code>filter</code></td>
<td>过滤元素</td>
</tr>
<tr>
<td><code>reduce</code></td>
<td>聚合为一个值</td>
</tr>
<tr>
<td><code>compactMap</code></td>
<td>去除 nil 并转换</td>
</tr>
<tr>
<td><code>flatMap</code></td>
<td>展平嵌套结构</td>
</tr>
</tbody>
</table>
<h3 id="面试示例题">面试示例题</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> uppercased <span class="operator">=</span> names.map &#123; <span class="variable">$0</span>.lowercased() &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="🔁-五、Combine-基础面试题">🔁 五、Combine 基础面试题</h2>
<h3 id="❓-Combine-的核心组件有哪些？">❓ Combine 的核心组件有哪些？</h3>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Publisher</td>
<td>发布者，发出数据流</td>
</tr>
<tr>
<td>Subscriber</td>
<td>订阅者，接收数据流</td>
</tr>
<tr>
<td>Subject</td>
<td>可作为 Publisher 和订阅点</td>
</tr>
<tr>
<td>Operator</td>
<td>转换数据流，如 <code>map</code>, <code>filter</code></td>
</tr>
</tbody>
</table>
<h3 id="❓-示例：使用-Combine-实现双向绑定">❓ 示例：使用 Combine 实现双向绑定</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Published</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span></span><br><span class="line">    .sink &#123; <span class="built_in">print</span>(<span class="string">&quot;用户名：<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">    .store(in: <span class="operator">&amp;</span>cancellables)</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="🌊-六、RxSwift-基础面试题">🌊 六、RxSwift 基础面试题</h2>
<h3 id="❓-RxSwift-与-Combine-的异同？">❓ RxSwift 与 Combine 的异同？</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th>RxSwift</th>
<th>Combine</th>
</tr>
</thead>
<tbody>
<tr>
<td>苹果支持</td>
<td>❌ 第三方</td>
<td>✅ 官方</td>
</tr>
<tr>
<td>平台</td>
<td>iOS 9+</td>
<td>iOS 13+</td>
</tr>
<tr>
<td>错误处理</td>
<td><code>onError</code></td>
<td><code>Failure</code> 泛型</td>
</tr>
<tr>
<td>资源管理</td>
<td><code>DisposeBag</code></td>
<td><code>AnyCancellable</code></td>
</tr>
</tbody>
</table>
<h3 id="❓-如何创建-Observable？">❓ 如何创建 Observable？</h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="🗑️-七、ARC-内存管理面试题">🗑️ 七、ARC 内存管理面试题</h2>
<h3 id="❓-Swift-的-ARC-如何工作？">❓ Swift 的 ARC 如何工作？</h3>
<ul>
<li>自动引用计数（ARC）：每次引用计数 +1/-1</li>
<li>当计数为 0 时释放内存</li>
</ul>
<h3 id="❓-strong-weak-unowned-区别？">❓ strong / weak / unowned 区别？</h3>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>strong</code></td>
<td>默认，增加引用计数</td>
</tr>
<tr>
<td><code>weak</code></td>
<td>不增加计数，自动设为 nil</td>
</tr>
<tr>
<td><code>unowned</code></td>
<td>不增加计数，不设为 nil（危险）</td>
</tr>
</tbody>
</table>
<h3 id="❓-如何解决循环引用（Retain-Cycle）？">❓ 如何解决循环引用（Retain Cycle）？</h3>
<ul>
<li>弱引用委托模式 <code>delegate: SomeProtocol?</code></li>
<li>闭包中使用 <code>[weak self]</code> 捕获</li>
</ul>
<hr />
<h2 id="🧪-Bonus：Swift-面试设计题">🧪 Bonus：Swift 面试设计题</h2>
<ol>
<li>实现一个泛型缓存类</li>
<li>使用 RxSwift 实现登录输入校验</li>
<li>Combine 版网络请求封装器</li>
<li>如何用闭包替代 delegate？</li>
<li>使用协议实现多种网络层解耦</li>
</ol>
<hr />
<p>如果你希望我把这套完整面试题集整理成 Markdown、PDF、Xcode Playground、或面试笔记格式，我可以立即帮你生成。是否需要？或者还想深入 SwiftUI、内存布局、性能优化、源码解读等方向？</p>
<h1>iOS 面试题大全（Objective-C + Swift）</h1>
<hr />
<h2 id="一、语言基础">一、语言基础</h2>
<h3 id="Objective-C">Objective-C</h3>
<ol>
<li>Objective-C 的类和对象结构？</li>
<li>什么是 Category 和 Extension？有什么区别？</li>
<li>什么是 Selector？怎么调用？</li>
<li>id 和 instancetype 的区别？</li>
<li>@property 的属性修饰符有哪些？</li>
<li>什么是 KVC 和 KVO？原理是什么？</li>
<li>什么是 Runtime？你用过哪些 Runtime 特性？</li>
<li>如何实现一个动态方法交换（Method Swizzling）？</li>
</ol>
<h3 id="Swift">Swift</h3>
<ol>
<li>struct 和 class 的区别？</li>
<li>struct、class 初始化时属性/init 的注意事项？</li>
<li>class 是否可以服从 Codable 协议？</li>
<li>如何利用 Codable 协议兼容接口字段名和类型？</li>
<li>Optional 的本质是什么？</li>
<li>Swift 是值语义还是引用语义？</li>
<li>什么是 mutating 关键字？</li>
<li>enum 的高级用法有哪些？关联值、递归枚举？</li>
</ol>
<hr />
<h2 id="二、内存管理">二、内存管理</h2>
<ol>
<li>ARC 是什么？如何工作的？</li>
<li>强引用、弱引用、unowned 区别？</li>
<li>如何避免循环引用？delegate 用 weak？</li>
<li>Block（ObjC）或 Closure（Swift）如何导致循环引用？</li>
<li>@autoreleasepool 是做什么的？</li>
<li>MRC 和 ARC 有哪些不同？是否可以混用？</li>
</ol>
<hr />
<h2 id="三、多线程与并发">三、多线程与并发</h2>
<h3 id="GCD">GCD</h3>
<ol>
<li>GCD 的基本概念？同步/异步，串行/并行队列？</li>
<li>如何使用 DispatchGroup 实现任务组？</li>
<li>dispatch_barrier 有什么作用？</li>
<li>如何使用信号量 DispatchSemaphore 控制线程？</li>
</ol>
<h3 id="OperationQueue">OperationQueue</h3>
<ol>
<li>NSOperation 的优点是什么？如何自定义？</li>
<li>如何设置依赖？如何取消操作？</li>
</ol>
<h3 id="Swift-async-await">Swift async/await</h3>
<ol>
<li>Swift 中如何使用 async/await 实现并发任务？</li>
<li>async let 和 TaskGroup 的区别与使用场景？</li>
<li>actor 是什么？如何解决数据竞争？</li>
</ol>
<hr />
<h2 id="四、网络编程">四、网络编程</h2>
<ol>
<li>NSURLSession 常用方法？</li>
<li>如何处理 JSON？手动解析 vs Codable？</li>
<li>如何处理 HTTPS 双向验证？</li>
<li>如何实现断点续传？</li>
<li>AFNetworking 和 Alamofire 的底层原理？</li>
</ol>
<hr />
<h2 id="五、数据库与持久化">五、数据库与持久化</h2>
<ol>
<li>UserDefaults 用法和原理？</li>
<li>plist 存储适合什么场景？</li>
<li>Core Data 的基本使用？NSManagedObject？</li>
<li>如何设计 Core Data 的线程模型？</li>
<li>FMDB 和 SQLite 如何使用？</li>
</ol>
<hr />
<h2 id="六、设计模式">六、设计模式</h2>
<ol>
<li>MVC、MVP、MVVM 有什么区别？</li>
<li>单例模式如何实现（ObjC 和 Swift）？</li>
<li>观察者模式在 iOS 中的实现？</li>
<li>代理模式如何实现？delegate vs closure？</li>
<li>响应链模式（Responder Chain）是什么？</li>
</ol>
<hr />
<h2 id="七、常用框架">七、常用框架</h2>
<h3 id="Combine">Combine</h3>
<ol>
<li>Combine 的核心概念（Publisher/Subscriber/Operator）？</li>
<li>@Published 和 ObservableObject 有什么区别？</li>
<li>如何取消订阅？AnyCancellable？</li>
</ol>
<h3 id="RxSwift">RxSwift</h3>
<ol>
<li>什么是 Observable？Observer？</li>
<li>如何使用 Subjects？（Publish/Behavior/Replay/Async）</li>
<li>DisposeBag 有什么用？</li>
<li>RxSwift 与 Combine 有哪些异同？</li>
</ol>
<hr />
<h2 id="八、高阶-Swift-语法">八、高阶 Swift 语法</h2>
<ol>
<li>泛型如何定义？如何约束？</li>
<li>如何实现一个泛型缓存类？</li>
<li>Protocol 和 associatedtype 的高级用法？</li>
<li>Swift 的闭包语法和使用？</li>
<li>什么是逃逸闭包（@escaping）？</li>
<li>高阶函数：map/filter/reduce/flatMap/compactMap 的用法？</li>
<li>如何使用 Swift 的 Result 类型处理异步任务？</li>
</ol>
<hr />
<h2 id="九、其他基础知识">九、其他基础知识</h2>
<ol>
<li>App 的启动过程是什么？</li>
<li>iOS 的事件传递机制？（Hit-Testing）</li>
<li>UIResponder 的作用？</li>
<li>通知中心 NotificationCenter 原理？</li>
<li>iOS 的沙盒机制与目录结构？</li>
<li>App 生命周期与场景管理（SceneDelegate）？</li>
</ol>
<hr />
<p>欢迎根据职位要求重点准备某些模块，是否还需要我整理为 PDF 或可搜索的 Markdown 文件？
以下是对文档内容的进一步完善建议，包括<strong>新增几个关键面试模块与问题点</strong>，特别是：</p>
<ul>
<li>Swift 的属性包装器（Property Wrappers）</li>
<li>Swift 的访问控制与模块化</li>
<li>iOS 性能优化与调试工具</li>
<li>测试与 CI/CD 流程</li>
<li>iOS 安全机制</li>
</ul>
<p>你可以选择我来更新文档，也可以先看看新增内容如下：</p>
<hr />
<h2 id="十、Swift-进阶机制">十、Swift 进阶机制</h2>
<ol>
<li>Property Wrapper 的原理和常见用法（@State、@Published、@UserDefault 等）？</li>
<li>Swift 的访问控制（open、public、internal、fileprivate、private）有哪些场景？</li>
<li>Swift 的模块化开发方式？如何拆分模块？</li>
<li>如何实现依赖注入（DI）？有无使用框架（如 Resolver、Swinject）？</li>
</ol>
<hr />
<h2 id="十一、性能优化与调试">十一、性能优化与调试</h2>
<ol>
<li>Instruments 中常用工具有哪些？Time Profiler、Allocations、Leaks 的使用？</li>
<li>如何查找内存泄漏和性能瓶颈？</li>
<li>View 的离屏渲染（Offscreen Rendering）问题及优化？</li>
<li>如何优化列表滚动性能（特别是 SwiftUI）？</li>
</ol>
<hr />
<h2 id="十二、测试与-CI-CD">十二、测试与 CI/CD</h2>
<ol>
<li>单元测试、UI 测试的区别和框架（XCTest/XCUITest）？</li>
<li>如何进行 Mock 测试？</li>
<li>使用 Xcode Server、Jenkins、GitHub Actions 做 CI/CD？</li>
<li>Fastlane 的基本使用方法？</li>
</ol>
<hr />
<h2 id="十三、iOS-安全性">十三、iOS 安全性</h2>
<ol>
<li>iOS 应用如何做本地数据加密（Keychain 使用）？</li>
<li>什么是代码混淆与反调试手段？</li>
<li>iOS 的 App Transport Security（ATS）是什么？</li>
<li>如何处理用户隐私合规问题（IDFA、App Tracking Transparency）？</li>
</ol>
<hr />
<p>如你希望我将这些内容补充进当前 Canvas 文档，请回复“请更新文档”；或者如希望将其导出为 PDF 或 Markdown 文件，我也可直接生成。是否需要我继续整理更高阶的系统设计题？
在 Swift 中，<code>property getter</code> 和 <code>setter</code> 是属性访问的核心机制，允许你自定义属性的读取和写入行为。而 <code>willSet</code> 和 <code>didSet</code> 是 Swift 中<strong>存储属性的观察者（Property Observers）</strong>，用于在属性即将被设置前或刚被设置后响应操作。下面详细介绍这两类机制及它们的生命周期、作用与区别。</p>
<hr />
<h2 id="一、Getter-与-Setter（计算属性）">一、Getter 与 Setter（计算属性）</h2>
<p>**计算属性（Computed Property）**使用 <code>get</code> 和 <code>set</code> 明确地声明读取和写入逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> width <span class="operator">*</span> height</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// 可根据需要更新 width 或 height</span></span><br><span class="line">            width <span class="operator">=</span> sqrt(newValue)</span><br><span class="line">            height <span class="operator">=</span> sqrt(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期：">生命周期：</h3>
<ul>
<li><code>get</code> 在每次读取属性时调用。</li>
<li><code>set</code> 在每次设置属性值时调用。</li>
<li><code>set</code> 可省略参数名，使用系统默认的 <code>newValue</code>。</li>
<li>计算属性 <strong>不能使用 willSet/didSet</strong>（因为它们没有存储值）。</li>
</ul>
<hr />
<h2 id="二、willSet-与-didSet（存储属性观察者）">二、willSet 与 didSet（存储属性观察者）</h2>
<p>观察者用于监听<strong>存储属性</strong>的变化，常用于副作用操作（如 UI 更新、日志记录）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;即将设置 name 为 <span class="subst">\(newValue)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;name 已从 <span class="subst">\(oldValue)</span> 改为 <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期和执行顺序：">生命周期和执行顺序：</h3>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">（设置属性值发生时）</span><br><span class="line">1. willSet(newValue) 执行 —— 传入新的值</span><br><span class="line">2. 实际赋值 name = newValue</span><br><span class="line">3. didSet(oldValue) 执行 —— 传入旧的值</span><br></pre></td></tr></table></figure>
<h3 id="特点和规则：">特点和规则：</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>willSet</th>
<th>didSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>触发时机</td>
<td>设置前</td>
<td>设置后</td>
</tr>
<tr>
<td>是否可访问新旧值</td>
<td><code>newValue</code>（默认名）</td>
<td><code>oldValue</code>（默认名）</td>
</tr>
<tr>
<td>可否更改新值</td>
<td>❌（只读）</td>
<td>✅（但再次触发 willSet）</td>
</tr>
<tr>
<td>对比 get/set</td>
<td>是副作用处理</td>
<td>非属性逻辑/行为型处理</td>
</tr>
<tr>
<td>对比 get/set 应用场景</td>
<td>响应式（通知/记录/限制等）</td>
<td>不是值计算</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="三、get-set-与-willSet-didSet-的本质区别">三、get/set 与 willSet/didSet 的本质区别</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>get / set（计算属性）</th>
<th>willSet / didSet（观察者）</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否存在存储值</td>
<td>❌ 不存储数据，只计算</td>
<td>✅ 是真实的存储属性</td>
</tr>
<tr>
<td>可否添加计算逻辑</td>
<td>✅（如 area 计算）</td>
<td>✅（响应变化，如 UI 刷新）</td>
</tr>
<tr>
<td>支持作用范围</td>
<td>struct、class、enum 中所有属性</td>
<td>仅限 <strong>存储属性</strong>（不适用于计算属性）</td>
</tr>
<tr>
<td>使用场景</td>
<td>自定义属性值逻辑，如转换、代理其他属性</td>
<td>监听属性值变化，例如通知、同步更新</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="四、实践建议">四、实践建议</h2>
<ul>
<li>如果你想自定义 <strong>属性值的逻辑</strong>（如格式转换），使用 <code>get/set</code>。</li>
<li>如果你想在 <strong>属性变化时响应操作</strong>（如 UI 通知或日志记录），使用 <code>willSet/didSet</code>。</li>
<li>避免在 <code>didSet</code> 中再次改变该属性值，容易引发递归循环。</li>
<li>只在确实需要响应属性变化时使用观察者，否则可能影响性能或可读性。</li>
</ul>
<hr />
<p>在 Swift 中，属性的 <strong>getter</strong>、<strong>setter</strong> 及其观察器（<code>willSet</code>、<code>didSet</code>）的生命周期和调用顺序是属性管理的核心机制。以下是它们的详细解析：</p>
<hr />
<h3 id="1-基本结构-2"><strong>1. 基本结构</strong></h3>
<p>Swift 中的属性可以分为：</p>
<ul>
<li><strong>存储属性（Stored Property）</strong>：直接存储值，可附加观察器。</li>
<li><strong>计算属性（Computed Property）</strong>：通过 getter/setter 动态计算值，不可附加观察器。</li>
</ul>
<h4 id="示例代码-2"><strong>示例代码</strong></h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 存储属性 + 观察器</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;willSet: <span class="subst">\(name)</span> → <span class="subst">\(newValue)</span>&quot;</span>) &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;didSet: <span class="subst">\(oldValue)</span> → <span class="subst">\(name)</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">var</span> uppercaseName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name.uppercased() &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; name <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="2-Getter-和-Setter-的生命周期-2"><strong>2. Getter 和 Setter 的生命周期</strong></h3>
<h4 id="1-计算属性（Computed-Property）-2"><strong>(1) 计算属性（Computed Property）</strong></h4>
<ul>
<li><strong>Getter</strong>：每次访问属性时调用。</li>
<li><strong>Setter</strong>：每次赋值时调用（必须有 <code>set</code> 才能修改值）。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(person.uppercaseName) <span class="comment">// 调用 getter</span></span><br><span class="line">person.uppercaseName <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span> <span class="comment">// 调用 setter → 触发 name 的观察器</span></span><br></pre></td></tr></table></figure>
<h4 id="2-存储属性（Stored-Property）-2"><strong>(2) 存储属性（Stored Property）</strong></h4>
<ul>
<li><strong>默认行为</strong>：直接读写存储的值。</li>
<li><strong>附加观察器</strong>：通过 <code>willSet</code> 和 <code>didSet</code> 监听变化。</li>
</ul>
<hr />
<h3 id="3-观察器（willSet-和-didSet）的生命周期-2"><strong>3. 观察器（<code>willSet</code> 和 <code>didSet</code>）的生命周期</strong></h3>
<h4 id="调用顺序-2"><strong>调用顺序</strong></h4>
<p>当属性值被修改时，触发顺序如下：</p>
<ol>
<li><strong>原始值</strong>：保存当前值（用于 <code>didSet</code> 的 <code>oldValue</code>）。</li>
<li><strong><code>willSet</code></strong>：新值即将写入（可访问 <code>newValue</code>）。</li>
<li><strong>赋值操作</strong>：实际修改存储的值。</li>
<li><strong><code>didSet</code></strong>：新值已写入（可访问 <code>oldValue</code>）。</li>
</ol>
<h4 id="示例流程-2"><strong>示例流程</strong></h4>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// willSet: Alice → Bob</span></span><br><span class="line"><span class="comment">// didSet: Alice → Bob</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="4-关键区别与作用-2"><strong>4. 关键区别与作用</strong></h3>
<table>
<thead>
<tr>
<th>机制</th>
<th>触发时机</th>
<th>可访问的值</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Getter</strong></td>
<td>每次读取属性时</td>
<td>返回计算值</td>
<td>动态计算属性值（如格式化数据）。</td>
</tr>
<tr>
<td><strong>Setter</strong></td>
<td>每次赋值时（计算属性）</td>
<td><code>newValue</code></td>
<td>验证或处理新值（如过滤非法输入）。</td>
</tr>
<tr>
<td><strong><code>willSet</code></strong></td>
<td>值被写入前</td>
<td><code>newValue</code></td>
<td>执行前置操作（如日志记录、触发 UI 更新）。</td>
</tr>
<tr>
<td><strong><code>didSet</code></strong></td>
<td>值被写入后</td>
<td><code>oldValue</code></td>
<td>执行后置操作（如数据同步、发送通知）。</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="5-高级场景与注意事项-2"><strong>5. 高级场景与注意事项</strong></h3>
<h4 id="1-初始化阶段不触发观察器-2"><strong>(1) 初始化阶段不触发观察器</strong></h4>
<ul>
<li><strong>观察器仅在初始化完成后生效</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name <span class="comment">// 不会触发 willSet/didSet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-避免在-didSet-中重复触发修改-2"><strong>(2) 避免在 <code>didSet</code> 中重复触发修改</strong></h4>
<ul>
<li><strong>死循环风险</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        score <span class="operator">=</span> <span class="built_in">min</span>(score, <span class="number">100</span>) <span class="comment">// 会再次触发 didSet！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>解决方案</strong>：通过临时变量或条件判断避免循环。</li>
</ul>
<h4 id="3-计算属性与观察器的互斥-2"><strong>(3) 计算属性与观察器的互斥</strong></h4>
<ul>
<li><strong>计算属性不能附加观察器</strong>（因为它的值由 getter/setter 动态决定）。</li>
</ul>
<h4 id="4-性能影响-2"><strong>(4) 性能影响</strong></h4>
<ul>
<li><strong>观察器会增加调用开销</strong>：高频修改的属性需谨慎使用。</li>
</ul>
<hr />
<h3 id="6-综合示例-2"><strong>6. 综合示例</strong></h3>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Temperature</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> celsius: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;摄氏温度即将从 <span class="subst">\(celsius)</span> 变为 <span class="subst">\(newValue)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> celsius <span class="operator">&gt;</span> <span class="number">100</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;警告：温度超过 100°C&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fahrenheit: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> celsius <span class="operator">*</span> <span class="number">1.8</span> <span class="operator">+</span> <span class="number">32</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; celsius <span class="operator">=</span> (newValue <span class="operator">-</span> <span class="number">32</span>) <span class="operator">/</span> <span class="number">1.8</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp <span class="operator">=</span> <span class="type">Temperature</span>()</span><br><span class="line">temp.fahrenheit <span class="operator">=</span> <span class="number">212</span> <span class="comment">// 触发 celsius 的观察器</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// willSet: 0.0 → 100.0</span></span><br><span class="line"><span class="comment">// 警告：温度超过 100°C</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="总结-2"><strong>总结</strong></h3>
<ul>
<li><strong>Getter/Setter</strong>：控制属性的读写行为（计算属性专属）。</li>
<li><strong><code>willSet</code>/<code>didSet</code></strong>：监听存储属性的变化（初始化时不触发）。</li>
<li><strong>设计原则</strong>：
<ul>
<li>用计算属性封装派生数据。</li>
<li>用观察器处理副作用（如持久化、UI 更新）。</li>
<li>避免在观察器中修改自身属性导致循环。</li>
</ul>
</li>
</ul>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2024/06/21/my-decade/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2025/09/02/self_learning_cnn/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: 'e929305d1df52067f223',
  clientSecret: '465557188fddc6608846e97927bc2fe7a268f141',
  repo: 'blog-comments',
  owner: 'niyaoyao',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['niyaoyao'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
