<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Swift Struct 和 Class 的区别 | N.Y.</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="interview," />
  

  <meta name="description" content="Swift 面试题一、Struct 和 Class 的区别 问题: Swift 中 struct 和 class 的主要区别是什么？答案:  值类型 vs 引用类型: struct 是值类型，复制时创建新副本；class 是引用类型，复制时共享同一实例。 继承: class 支持继承，struct 不支持。 内存管理: struct 通常在栈上分配，class 在堆上分配，需 ARC 管理。 初始">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift Struct 和 Class 的区别">
<meta property="og:url" content="http://niyaoyao.me/2025/06/09/interview-Swift%20Interview%20Questions/index.html">
<meta property="og:site_name" content="N.Y.">
<meta property="og:description" content="Swift 面试题一、Struct 和 Class 的区别 问题: Swift 中 struct 和 class 的主要区别是什么？答案:  值类型 vs 引用类型: struct 是值类型，复制时创建新副本；class 是引用类型，复制时共享同一实例。 继承: class 支持继承，struct 不支持。 内存管理: struct 通常在栈上分配，class 在堆上分配，需 ARC 管理。 初始">
<meta property="og:locale">
<meta property="article:published_time" content="2025-06-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-09T12:49:20.858Z">
<meta property="article:author" content="Niyao">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/favicon.ico/images/avatar_ny.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 5.4.2"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">Hi~</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">Hi~</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Swift 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Struct-%E5%92%8C-Class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">一、Struct 和 Class 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Struct-%E5%92%8C-Class-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">二、Struct 和 Class 初始化时的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Class-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%9C%8D%E4%BB%8E-Codable-%E5%8D%8F%E8%AE%AE"><span class="toc-text">三、Class 是否可以服从 Codable 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Optional-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">四、Optional 的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">五、多线程编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Swift-%E8%AF%AD%E6%B3%95%E9%A2%86%E5%9F%9F"><span class="toc-text">六、Swift 语法领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-text">七、综合问题</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-interview-Swift Interview Questions" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Swift Struct 和 Class 的区别</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2025.06.09</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Niyao</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="Swift-面试题"><a href="#Swift-面试题" class="headerlink" title="Swift 面试题"></a>Swift 面试题</h1><h2 id="一、Struct-和-Class-的区别"><a href="#一、Struct-和-Class-的区别" class="headerlink" title="一、Struct 和 Class 的区别"></a>一、Struct 和 Class 的区别</h2><ol>
<li><p><strong>问题</strong>: Swift 中 struct 和 class 的主要区别是什么？<br><strong>答案</strong>:</p>
<ul>
<li><strong>值类型 vs 引用类型</strong>: struct 是值类型，复制时创建新副本；class 是引用类型，复制时共享同一实例。</li>
<li><strong>继承</strong>: class 支持继承，struct 不支持。</li>
<li><strong>内存管理</strong>: struct 通常在栈上分配，class 在堆上分配，需 ARC 管理。</li>
<li><strong>初始化</strong>: struct 自动生成成员初始化器，class 需手动定义。</li>
<li><strong>可变性</strong>: struct 的 mutating 方法需显式声明，class 方法默认可修改实例。</li>
<li><strong>使用场景</strong>: struct 适合简单数据模型（如 DTO），class 适合复杂对象（如视图控制器）。</li>
</ul>
</li>
<li><p><strong>问题</strong>: 在什么情况下选择 struct 而不是 class？<br><strong>答案</strong>:</p>
<ul>
<li>数据模型简单，主要是存储数据。</li>
<li>需要值语义，避免共享状态。</li>
<li>线程安全要求高，值类型更易管理。</li>
<li>示例：表示点坐标的 <code>struct Point &#123; var x: Int, y: Int &#125;</code>。</li>
</ul>
</li>
</ol>
<h2 id="二、Struct-和-Class-初始化时的注意事项"><a href="#二、Struct-和-Class-初始化时的注意事项" class="headerlink" title="二、Struct 和 Class 初始化时的注意事项"></a>二、Struct 和 Class 初始化时的注意事项</h2><ol>
<li><p><strong>问题</strong>: struct 和 class 在初始化时，属性和 init 函数有哪些注意事项？<br><strong>答案</strong>:</p>
<ul>
<li><strong>属性初始化</strong>:<ul>
<li>非可选属性必须在初始化时赋值，或提供默认值。</li>
<li>常量（let）属性只能在初始化时赋值。</li>
<li>struct 自动生成成员初始化器（若无自定义 init），class 需显式定义。</li>
</ul>
</li>
<li><strong>init 函数</strong>:<ul>
<li>class 的 init 需确保所有非可选属性初始化完成。</li>
<li>class 支持指定初始化器（designated）和便利初始化器（convenience），convenience 必须调用 designated。</li>
<li>struct 的 init 不需要考虑继承，但若自定义 init，自动生成的成员初始化器失效。</li>
<li>deinit 仅适用于 class，用于释放资源。</li>
</ul>
</li>
<li><strong>注意事项</strong>:<ul>
<li>确保初始化安全，避免属性未初始化就使用。</li>
<li>class 的子类必须调用 super.init。</li>
<li>struct 的 mutating 方法可能影响初始化后的状态。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: class 的初始化器如何处理继承？<br><strong>答案</strong>:</p>
<ul>
<li>子类必须调用父类的指定初始化器（super.init）。</li>
<li>子类可以重写父类的指定初始化器，但必须满足父类的初始化要求。</li>
<li>便利初始化器不能被子类直接调用，只能通过指定初始化器间接调用。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">breed</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.breed <span class="operator">=</span> breed</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="三、Class-是否可以服从-Codable-协议"><a href="#三、Class-是否可以服从-Codable-协议" class="headerlink" title="三、Class 是否可以服从 Codable 协议"></a>三、Class 是否可以服从 Codable 协议</h2><ol>
<li><p><strong>问题</strong>: class 是否可以服从 Codable 协议？如何实现？<br><strong>答案</strong>:</p>
<ul>
<li>是的，class 可以服从 Codable 协议（包括 Encodable 和 Decodable）。</li>
<li>实现方式：<ul>
<li>确保 class 的所有存储属性都符合 Codable。</li>
<li>若属性是自定义类型，自定义类型也需符合 Codable。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意：class 的继承需要额外处理，父类和子类都需符合 Codable，且可能需要自定义编码/解码逻辑。</li>
</ul>
</li>
<li><p><strong>问题</strong>: 如何利用 Codable 协议兼容接口下发的字段类型或字段名？<br><strong>答案</strong>:</p>
<ul>
<li><strong>兼容字段名</strong>:<ul>
<li>使用 <code>CodingKeys</code> 枚举映射接口字段名和 Swift 属性名。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> userName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> userAge: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> userName <span class="operator">=</span> <span class="string">&quot;name&quot;</span></span><br><span class="line">        <span class="keyword">case</span> userAge <span class="operator">=</span> <span class="string">&quot;age&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>兼容字段类型</strong>:<ul>
<li>自定义 <code>init(from:)</code> 和 <code>encode(to:)</code> 方法处理类型转换。</li>
<li>示例（处理服务端返回的 age 可能是 String 或 Int）：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name, age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        name <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> ageInt <span class="operator">=</span> <span class="keyword">try?</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .age) &#123;</span><br><span class="line">            age <span class="operator">=</span> ageInt</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> ageString <span class="operator">=</span> <span class="keyword">try?</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .age) &#123;</span><br><span class="line">            age <span class="operator">=</span> <span class="type">Int</span>(ageString) <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            age <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li>使用 <code>try?</code> 优雅处理解码失败。</li>
<li>可结合 <code>PropertyWrapper</code> 简化复杂类型转换。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="四、Optional-的本质"><a href="#四、Optional-的本质" class="headerlink" title="四、Optional 的本质"></a>四、Optional 的本质</h2><ol>
<li><strong>问题</strong>: Optional 的本质是什么？<br><strong>答案</strong>:<ul>
<li>Optional 是一个枚举类型，定义如下：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Optional</span>&lt;<span class="type">Wrapped</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>本质</strong>:<ul>
<li>表示一个值可能存在（some）或不存在（none）。</li>
<li>提供安全的方式处理空值，避免运行时崩溃。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li>解包：<code>if let</code>, <code>guard let</code>, <code>??</code>, <code>map</code>, <code>flatMap</code>。</li>
<li>链式调用：<code>optional?.property?.method()</code>。</li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li>避免强制解包（<code>!</code>），除非确定值存在。</li>
<li>Optional 是 Swift 类型安全的基石。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="五、多线程编程"><a href="#五、多线程编程" class="headerlink" title="五、多线程编程"></a>五、多线程编程</h2><ol>
<li><p><strong>问题</strong>: 解释 Swift 中的 GCD 多线程编程及其常见用法。<br><strong>答案</strong>:</p>
<ul>
<li><strong>GCD（Grand Central Dispatch）</strong>:<ul>
<li>苹果提供的并发框架，用于管理任务队列和线程。</li>
<li>核心概念：DispatchQueue（串行/并发）、DispatchGroup、DispatchSemaphore。</li>
</ul>
</li>
<li><strong>常见用法</strong>:<ul>
<li><strong>异步任务</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="comment">// 后台任务</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// 更新 UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>串行队列</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.example.serial&quot;</span>)</span><br><span class="line">serialQueue.async &#123; <span class="comment">/* 任务 1 */</span> &#125;</span><br><span class="line">serialQueue.async &#123; <span class="comment">/* 任务 2 */</span> &#125; <span class="comment">// 按顺序执行</span></span><br></pre></td></tr></table></figure></li>
<li><strong>DispatchGroup</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">group.enter()</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="comment">// 任务 1</span></span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    <span class="comment">// 所有任务完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li>避免在主线程执行耗时任务。</li>
<li>合理使用 QoS（服务质量）优先级。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: 解释 Swift 的 Task 和 async/await 多线程编程。<br><strong>答案</strong>:</p>
<ul>
<li><strong>async/await</strong>:<ul>
<li>Swift 5.5 引入的结构化并发模型，简化异步编程。</li>
<li>使用 <code>async</code> 标记异步函数，<code>await</code> 暂停等待结果。</li>
</ul>
</li>
<li><strong>Task</strong>:<ul>
<li>用于启动异步任务，运行于并发上下文。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">fetchData</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://example.com&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> fetchData()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data fetched&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>并发模型</strong>:<ul>
<li><strong>Task Group</strong>：并行执行多个任务。<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">5</span> &#123;</span><br><span class="line">        group.addTask &#123; <span class="keyword">return</span> i <span class="operator">*</span> <span class="number">2</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> results: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> value <span class="keyword">in</span> group &#123;</span><br><span class="line">        results.append(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>Actor</strong>：线程安全的引用类型，避免数据竞争。<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>() &#123; value <span class="operator">+=</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li>使用 <code>@MainActor</code> 确保 UI 更新在主线程。</li>
<li>避免在非异步上下文中直接调用 async 函数。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: GCD 和 async/await 的区别和适用场景？<br><strong>答案</strong>:</p>
<ul>
<li><strong>GCD</strong>:<ul>
<li>更底层，适合精细控制线程和队列。</li>
<li>适用于简单后台任务或需要 DispatchGroup/Semaphore 的场景。</li>
<li>代码复杂，容易出现回调地狱。</li>
</ul>
</li>
<li><strong>async/await</strong>:<ul>
<li>更现代化，代码简洁，适合结构化并发。</li>
<li>适用于网络请求、文件操作等异步任务。</li>
<li>提供更好的错误处理（try/catch）。</li>
</ul>
</li>
<li><strong>选择</strong>:<ul>
<li>新项目优先使用 async/await。</li>
<li>旧代码或特定场景（如复杂队列管理）使用 GCD。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="六、Swift-语法领域"><a href="#六、Swift-语法领域" class="headerlink" title="六、Swift 语法领域"></a>六、Swift 语法领域</h2><ol>
<li><p><strong>问题</strong>: Protocol 的作用和使用场景是什么？<br><strong>答案</strong>:</p>
<ul>
<li><strong>作用</strong>:<ul>
<li>定义接口，规定类型必须实现的属性和方法。</li>
<li>支持多态和解耦。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li>数据源/代理模式（如 UITableViewDataSource）。</li>
<li>类型约束（如泛型）。</li>
<li>扩展功能（如 Equatable）。</li>
</ul>
</li>
<li><strong>示例</strong>:<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">move</span>(<span class="params">to</span> <span class="params">point</span>: <span class="type">CGPoint</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">move</span>(<span class="params">to</span> <span class="params">point</span>: <span class="type">CGPoint</span>) &#123; <span class="built_in">print</span>(<span class="string">&quot;Move to <span class="subst">\(point)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: 泛型的作用和常见用法？<br><strong>答案</strong>:</p>
<ul>
<li><strong>作用</strong>:<ul>
<li>提高代码复用性和类型安全。</li>
<li>允许函数/类型在不同类型间通用。</li>
</ul>
</li>
<li><strong>用法</strong>:<ul>
<li>泛型函数：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swap</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型类型：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123; items.append(item) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>协议关联类型：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li>使用 <code>where</code> 约束泛型类型。</li>
<li>泛型可提升性能（避免 Any 类型）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: 闭包的定义、捕获列表和逃逸闭包？<br><strong>答案</strong>:</p>
<ul>
<li><strong>闭包定义</strong>:<ul>
<li>自包含的代码块，可捕获上下文变量。</li>
<li>语法：<code>&#123; (parameters) -&gt; ReturnType in statements &#125;</code></li>
</ul>
</li>
<li><strong>捕获列表</strong>:<ul>
<li>控制闭包如何捕获变量（值/引用）。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> closure <span class="operator">=</span> &#123; [x] <span class="keyword">in</span> <span class="built_in">print</span>(x) &#125; <span class="comment">// 捕获 x 的值</span></span><br><span class="line">x <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">closure() <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>逃逸闭包</strong>:<ul>
<li>闭包在函数返回后仍可被调用，需标记 <code>@escaping</code>。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> completion: (() -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">performTask</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.completion <span class="operator">=</span> completion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: 高阶函数（如 map、filter、reduce）的用途和示例？<br><strong>答案</strong>:</p>
<ul>
<li><strong>用途</strong>:<ul>
<li>函数式编程核心，用于处理集合数据。</li>
<li>提高代码简洁性和可读性。</li>
</ul>
</li>
<li><strong>示例</strong>:<ul>
<li><strong>map</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> doubled <span class="operator">=</span> numbers.map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125; <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>filter</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> evens <span class="operator">=</span> numbers.filter &#123; <span class="variable">$0</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> &#125; <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>reduce</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> numbers.reduce(<span class="number">0</span>) &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span> &#125; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: Combine 框架的核心概念和使用场景？<br><strong>答案</strong>:</p>
<ul>
<li><strong>核心概念</strong>:<ul>
<li>响应式编程框架，处理异步事件流。</li>
<li>核心组件：Publisher、Subscriber、Operator。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li>网络请求、用户输入、状态变化。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"><span class="keyword">let</span> publisher <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].publisher</span><br><span class="line"><span class="keyword">let</span> cancellable <span class="operator">=</span> publisher</span><br><span class="line">    .map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125; <span class="comment">// 输出 2, 4, 6</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>:<ul>
<li>使用 <code>AnyCancellable</code> 管理订阅生命周期。</li>
<li>Combine 适合复杂事件流处理。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: RxSwift 的核心概念和与 Combine 的区别？<br><strong>答案</strong>:</p>
<ul>
<li><strong>核心概念</strong>:<ul>
<li>基于观察者模式的响应式框架。</li>
<li>核心组件：Observable、Observer、Operator、Scheduler。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">let</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="type">Observable</span>.just([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    .map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125;</span><br><span class="line">    .subscribe(onNext: &#123; <span class="built_in">print</span>(<span class="variable">$0</span>) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></li>
<li><strong>与 Combine 的区别</strong>:<ul>
<li>Combine 是苹果原生框架，RxSwift 是第三方库。</li>
<li>Combine 集成 Swift 语言特性（如 property wrapper）。</li>
<li>RxSwift 社区更大，跨平台支持更好。</li>
</ul>
</li>
<li><strong>选择</strong>:<ul>
<li>新项目推荐 Combine，跨平台项目用 RxSwift。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>问题</strong>: ARC 内存管理的原理和常见问题？<br><strong>答案</strong>:</p>
<ul>
<li><strong>原理</strong>:<ul>
<li>自动引用计数（ARC）跟踪对象引用，引用计数为 0 时释放。</li>
<li>强引用（strong）、弱引用（weak）、无主引用（unowned）。</li>
</ul>
</li>
<li><strong>常见问题</strong>:<ul>
<li><strong>循环引用</strong>：<ul>
<li>两个对象互相强引用，导致内存泄漏。</li>
<li>解决：使用 weak 或 unowned。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dog: <span class="type">Dog</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> owner: <span class="type">Person</span>? <span class="comment">// 避免循环引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>闭包捕获</strong>：<ul>
<li>闭包捕获 self 可能导致循环引用。</li>
<li>解决：使用捕获列表 <code>[weak self]</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li>weak 引用可能为 nil，unowned 假设引用始终有效。</li>
<li>使用 <code>@MainActor</code> 或 actor 避免并发内存问题。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="七、综合问题"><a href="#七、综合问题" class="headerlink" title="七、综合问题"></a>七、综合问题</h2><ol>
<li><p><strong>问题</strong>: 设计一个线程安全的单例类，支持 Codable，并处理网络请求。<br><strong>答案</strong>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NetworkManager</span>: <span class="title class_ inherited__">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">NetworkManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> urlSession <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> dummy <span class="comment">// 示例用，实际根据需求定义</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container <span class="operator">=</span> encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="comment">// 编码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 解码逻辑，单例无需恢复实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fetchData</span>&lt;<span class="type">T</span>: <span class="type">Decodable</span>&gt;(<span class="params">from</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (data, <span class="keyword">_</span>) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> urlSession.data(from: url)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">T</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>问题</strong>: 如何优化 Swift 代码性能？<br><strong>答案</strong>:</p>
<ul>
<li>使用 struct 减少堆分配。</li>
<li>避免过度使用 Any 和 as? 转换。</li>
<li>使用 final 关键字避免动态分发。</li>
<li>优化集合操作，优先使用 map/filter 替代循环。</li>
<li>使用 Instruments 分析内存和 CPU 使用。</li>
</ul>
</li>
<li><p><strong>问题</strong>: Swift 6 的主要更新有哪些？<br><strong>答案</strong>:</p>
<ul>
<li><strong>数据竞争安全</strong>：引入严格的并发检查，强制使用 actor 或 Sendable 协议。</li>
<li><strong>Typed throws</strong>：支持指定抛出错误类型。</li>
<li><strong>增强泛型</strong>：更灵活的泛型约束。</li>
<li><strong>注意</strong>：需调整现有代码以适配并发检查。</li>
</ul>
</li>
</ol>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2025/06/09/interview-Swift%20Property%20Getter%20and%20Setter%20Lifecycle/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2025/06/09/Interview%20Questions/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: 'e929305d1df52067f223',
  clientSecret: '465557188fddc6608846e97927bc2fe7a268f141',
  repo: 'blog-comments',
  owner: 'niyaoyao',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['niyaoyao'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
